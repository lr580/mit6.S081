## 环境部署

[环境部署官方参考](https://pdos.csail.mit.edu/6.828/2021/tools.html)

windows 为例，假设已经装了 wsl，在管理员 power shell 启动 wsl。

```sh
wsl -u root # 不然非管理员用户登录
```

安装必要依赖：

```sh
sudo apt-get update && sudo apt-get upgrade
sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu
```

访问 wsl 根目录，在文件资源管理器输入路径：`\\wsl$\Ubuntu-20.04`(具体看自己的 wsl 版本，可以通过 `wsl --list` 查看)

随便找一个目录 clone 并 cd：[参考](http://www.systee.com/posts/4be1f6bb/)

```sh
git clone git://g.csail.mit.edu/xv6-labs-2021
cd xv6-labs-2021
```

编译：

```sh
git checkout util
make qemu
```

之后进入一个 xv6 CLI，可以执行：[参考官方](https://pdos.csail.mit.edu/6.S081/2021/labs/util.html)

```sh
ls
```

退出方法：先按 `ctrl+a`，然后直接按 `x`(不是一边按 `ctrl+a` 一边 `ctrl+x` 或 `ctrl+a+x`)。

vscode 配置，安装插件 `remote-wsl`(或名为 `wsl`，特征为蓝色背景白色企鹅)。[参考](http://www.systee.com/posts/4be1f6bb/)

在 wsl terminal 内在项目根目录执行：`code .`，弹出 vsc 窗口。

更改文件权限，以自己的为例，这样才能让 vsc 和 windows 文件资源管理器可以写：

```sh
sudo chmod -R 777 /home/lr583/xv6-labs-2021
```

因为实际上 wsl 内的东西不在一个逻辑机，所以 git 比较麻烦，必须用 wsl terminal 来 add, commit(本机的 git bash 的话一 `git add .` 就把东西全删了，理由未知)，然后因为用户要用到本机的，所以在 git bash 里搞 `git push`。

对 vsc，注意到在 wsl 和在本机插件独立，所以给 wsl 装一个 `C/C++` 插件。安装完成的话，对要调用的函数，进行 ctrl 单机能定位到出处。

部署完毕，即通过 [要求](https://pdos.csail.mit.edu/6.S081/2021/labs/util.html) 的 boot xv6 任务。

注意到 wsl 内需要配置 git 用户名和邮箱，不然 git log 看到的不是自己，github 也没有自己的 commits 记录。将本机公钥私钥覆盖虚拟机的，如管理员就把 `id_rsa`, `id_rsa.pub` 丢到 `/root/.ssh` 里，可以先通过 vscode WSL 插件丢到项目目录，然后 `mv` 过去即可。



## 开发任务

### lab1 util

[参考](https://pdos.csail.mit.edu/6.S081/2021/labs/util.html) 实现 util

#### sleep

##### 要求

要阅读 [文档](https://pdos.csail.mit.edu/6.S081/2021/xv6/book-riscv-rev2.pdf) 第一章，或参考 `user/echo.c` 写好的方法，查看编写格式，即如何进行输入输出。

注意到 main 函数参数 `argc` 是传进去的参数数目，`argv` 是这些参数。注意到 `argv[1]` 开始才是真的第一个参数，即传入的第二个参数。从 `echo` 也可印证这一点。

根据文档第 13 页，可以看到 `write` 函数的参数描述，它可以通过 `#include "user/user.h"` 引用，第一个参数是 file descriptor 文件描述符，整数；第二个参数是字符串指针(空指针)，第三个参数是字符数(在 `user/ulib.c` 手写了 `strlen` 函数)，在文档第 13 页头，描述了常用的几个文件描述符：①0 标准输入；②1 标准输出；③2 标准错误输出(`stderr`)

传入一个参数，可以使用 `user/ulib.c` 的 `atoi` 函数转 char 为 int。在 `kernel/sysproc.c` 有 `sys_sleep` 的手写函数，代表了 `sleep` 的核心逻辑。在 `user/user.h` 提供了调用的 `sleep` 函数。`user/usys.S` 汇编语言，部分代码表示进入内核态执行 sleep。

具体而言，检查传入的参数，如果不够 1 个或其他原因报错，正常情况 exit。在根目录看到 `Makefile`，需要添加一些东西。

##### 实现

> 一个参考实现 [here](https://blog.miigon.net/posts/s081-lab1-unix-utilities/) [汇总](https://github.com/Miigon/my-xv6-labs-2020)

因为对项目架构不太懂，所以暂且参考了一下现成代码。

具体而言，新建一个 `user/sleep.c`，代码如下：

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"
// the above 3 headers must be includes in such exact orders
int main(int argc, char **argv)
{
    if (argc < 2)
    { //一个 ticks 目测大约 100ms
        printf("usage: sleep <ticks>\n");
    }
    int ticks = atoi(argv[1]);
    sleep(ticks);
    exit(0);
}
```

在 makefile `UPROGS=` 那一堆追加：

```makefile
$U/_sleep\
```

验证正确性：

```sh
make qemu
sleep 10
# 关闭
```

单元测试：

```sh
./grade-lab-util sleep
```

#### pingpong

##### 要求

使用管道，实现一对进程的测试通信。父进程给子进程发送一个字节(byte)，子进程输出 `<pid>: received ping`，然后将收到的字节发回去，父进程输出 `<pid>: received pong`。在 `user/pingpong.c` 实现。

需要用到的函数：

- `int pipe(int*);` 传入一个长为 2 的 int 数组，下标 0 是从管道读取数据的文件描述符，下标 1 是向管道写入数据的文件描述符。参考文档第 15 页。一个管道是半双工的，一方读一方写。

- `int fork(void);` 参考文档第 10 页，创建一个当前进程的子进程，返回新建进程的 pid。新进程的内存内容与原进程一样。此时，进入并发，被新建的进程的 `fork` 返回 0,。所以如果调用了 fork，根据返回值判断当前程序代码是被父进程还是子进程走，需要 if else。

- `int read(int, void*, int);` 第一个参数是管道的第一个下标 0 代表的描述符，代表从这个管道读，第二个参数是 char(按地址传入，或指针)，读一个字节，第三个参数代表第二个参数的字符长度。如果读不到，会阻塞等待，直到读到了再往下走。参考文档第 15 页。如果管道写侧关闭，会返回 0。

  同理有 `int write(int, const void*, int)`，第一个传的是管道下标 1 的值

- `int getpid();` 参考文档第 11 页。直接返回当前进程 pid。

- `int exit(int status)` 参考文档第 11 页。结束运行。参考 11 页尾，0 是成功，1 是失败。

- `int wait(int*)` 参考文档第 11 页。等待直接子进程结束，结束后继续执行，否则阻塞，以传入的状态 `int * status` 结束，返回子进程 pid。更多参见 11 页尾。如果有很多个子，可以 `while(wait(0) != -1);` 自旋等。

##### 实现

按照题意实现即可。

```c
int main(int argc, char **argv)
{
    int pp2c[2]; // pipe parent to child
    pipe(pp2c);
    int pc2p[2]; // pipe child to parent
    pipe(pc2p);
    if (fork() != 0) // parent process
    {
        write(pp2c[1], "+", 1); // any char with length 1
        char c;
        read(pc2p[0], &c, 1); // read char of length 1
        printf("%d: received pong\n", getpid());
        wait(0);
    } else {
        char c;
        read(pp2c[0], &c, 1);
        printf("%d: received ping\n", getpid());
        write(pc2p[1], &c, 1);
    }
    exit(0);
}
```

记得添加 makefile。

测试：

```sh
make qemu
pingpong
```



#### primes

##### 要求

使用管道并发地获取质数，写在 `user/primes.c`，输出 [2,35] 的全部质数。对每个质数，创建一个进程用管道读取它的左邻居，写给它的右邻居。

提示：

- 关闭进程不需要的文件需要小心，否则可能会资源枯竭。
- 首个进程到达 35 时，需要等待管道终止，即它的全部子孙，即主进程应在所有输出都完毕后再关闭
- 注意写侧管道关闭会 read 返回 0
- 最简单是直接把 int 写进管道，而不是格式化

参考实现思路文章 [这里](https://swtch.com/~rsc/thread/)

参考函数：

- `int close(int)` 关闭文件描述符

##### 实现

- 主进程生成 [2,35] 的全部质数
- 子进程1 输出2，筛掉所有 2 的倍数
- 子进程2 输出3，筛掉所有 3 的倍数
- 子进程3 输出5，筛掉所有 5 的倍数
- ……

具体而言，每个进程有一个父，数据交换为 pleft，子从父读全部数据，输出第一个数据，然后剩下的数据把倍数筛了，再丢给下一个进程处理，如此递归，然后每个线程都等待自己的儿子结束自己再结束。

要注意关闭不需要用到的文件描述符，否则跑到 n = 13 的时候就会爆掉，出现读到全是 0 的情况，因为 xv6 每个进程能打开的文件描述符总数只有 16 个，参考 `defs.h` 中的 `NOFILE` 和 `proc.h` 中的 `struct file *ofile[NOFILE]; // Open files`。

由于一个管道会同时打开一个输入文件和一个输出文件，所以一个管道就占用了 2 个文件描述符，并且复制的子进程还会复制父进程的描述符，于是跑到第六七层后，就会由于最末端的子进程出现 16 个文件描述符都被占满的情况，导致新管道创建失败。

所以：

- 关闭管道的两个方向中不需要用到的方向的文件描述符（在具体进程中将管道变成只读/只写）
- 子进程创建后，关闭父进程与祖父进程之间的文件描述符（因为子进程并不需要用到之前 stage 的管道）

参考：

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

void filt(int[2]);
int main(int argc, char **argv)
{
    int input_pipe[2];
    pipe(input_pipe);
    if (fork() != 0) // parent process
    {
        close(input_pipe[0]); // no need to input
        int i;
        for (i = 2; i <= 35; ++i)
        {
            write(input_pipe[1], &i, sizeof i);
        }
        i = -1; // denotes completed
        write(input_pipe[1], &i, sizeof i);
    }
    else
    {
        close(input_pipe[1]); // no need to output
        filt(input_pipe);
        exit(0);
    }
    wait(0);
    exit(0);
}
// pipe left
// read one prime, and delete all its multiples
void filt(int pleft[2])
{
    int p; // prime
    read(pleft[0], &p, sizeof p);
    if (p == -1)
    {
        exit(0);
    }
    printf("prime %d\n", p);

    int pright[2]; // pipe right
    pipe(pright);
    if (fork() != 0) // parent process
    {
        close(pright[0]);
        int val;
        while (read(pleft[0], &val, sizeof val) && val != -1)
        {
            if (val % p)
            {
                write(pright[1], &val, sizeof val);
            }
        }
        val = -1;
        write(pright[1], &val, sizeof val);
        wait(0);
        exit(0);
    }
    else
    {
        close(pright[1]);
        close(pleft[0]);
        filt(pright);
    }
}
```



#### find

##### 要求

编写 `user/find.c`，找到目录下所有特定文件名的文件

参考 `user/ls.c` 查看如何读目录，参考函数：

- `int open(char *file, int flags)` 返回文件描述符，0 是最小的文件描述符，不存在返回负数。参考第 14 页，打开方式在 `kernel/fcntl.h` 描述，分别有 `O_RDONLY`, `O_WRONLY`, `O_RDWR`, `O_CREATE`, `O_TRUNC`。不存在就新建，不论读写。`trunc` 是清空。使用示例参考第 17-18 页。可以用 `|` 来如新建+只写。

- `int fstat(int fd, struct stat *st)` 或 `int stat(char *file, struct stat *st)`

  其中 `stat` 结构体在 `kernel/stat.h` 定义，描述了文件大小、文件是目录还是文件等信息。参考第 18 页。

使用递归来找子目录，不要重复找 `.` 和 `..`。注意对文件系统的改变是持久化的，清空文件系统使用 `make clean`，然后重新 `make qemu`。

`kernel/fs.h` 有 `struct dirent`，对目录用 `int read(int, void*, int)` 时第二个参数是 `fs.h` 里结构体 `dirent` 的地址，第三个参数是其长度，返回成功读取的长度，每次读取该目录的下一个路径，直到读完，可以当迭代器使用。返回成功读取的长度。其中 `dirent` 的成员 `inum` 仿照 `ls.c` 可知为 0 要跳过，`char name[14]` 是该目录下的一个文件名。 

参考测试样例：

```sh
make qemu
echo > b
mkdir a
echo > a/b
echo > a/a #我加的
find . b
# 文件系统包含 ./b 和 ./a/b
```

##### 实现

参考要求，仿照 `ls.c` 格式，不难得出具体实现：

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"
#include "kernel/fs.h"
#include "kernel/fcntl.h"

#define CHAR_LEN 512
void find(char *, char *);
int main(int argc, char *argv[])
{
    if (argc < 3)
    {
        printf("find: too few args");
        exit(0);
    }

    // target = "/"+argv[2] for convenience for cmp
    char target[CHAR_LEN];
    target[0] = '/';
    strcpy(target + 1, argv[2]);

    find(argv[1], target);
    exit(0);
}
// curr path: path, relative name to find: target
void find(char *path, char *target)
{
    int fd;
    fd = open(path, O_RDONLY);
    if (fd < 0)
    {
        fprintf(2, "find: cannot open %s\n", path);
        return;
    }

    struct stat st;
    if (fstat(fd, &st) < 0)
    {
        fprintf(2, "find: cannot stat %s\n", path);
        close(fd);
        return;
    }

    switch (st.type)
    {
    case T_FILE:
        // suffix is target
        if (strcmp(path + strlen(path) - strlen(target), target) == 0)
        {
            printf("%s\n", path);
        }
        break;
    case T_DIR:
    {//make a {} field to contains char buf
        char buf[CHAR_LEN], *p;
        // similar to user/ls.c line 50
        if (strlen(path) + 1 + DIRSIZ + 1 > sizeof buf)
        {
            printf("ls: path too long\n");
            break;
        }

        strcpy(buf, path);     // path prefix
        p = buf + strlen(buf); // pointer move
        *p++ = '/';            // cur pointer

        struct dirent de;
        while (read(fd, &de, sizeof(de)) == sizeof(de))
        {
            // similar to user/ls.c
            if (de.inum == 0)
            {
                continue;
            }
            // copy filename and add into buf, do not change position of p
            memmove(p, de.name, DIRSIZ);
            p[DIRSIZ] = '\0';

            if (stat(buf, &st) < 0)
            {
                printf("find: cannot stat %s\n", buf);
                continue;
            }

            // skip . and ..
            if (strcmp(buf + strlen(buf) - 2, "/.") != 0 &&
                strcmp(buf + strlen(buf) - 3, "/..") != 0)
            {
                find(buf, target);
            }
        }
        break;
    }
    }
    close(fd);
}
```

注意为了方便比较，可以让比较目标设定为 `/` + target，这样刚好对应，cmp 方便，免得假查。这个任务基本上就是对字符串匹配和 DFS 的小模拟，熟悉相关库函数和项目结构即可。

特别注意在 switch 内定义局部变量需要有作用域，所以 case 要加多一层大括号。

#### xagrs

##### 要求

通过管道，将输入传给 `xargs`，将输入逐行传给 xargs 执行其他命令，如：

```sh
echo hello too | xargs echo bye # 等于 xargs echo bye hello too 即 echo 输出拼上去
echo "1\n2" | xargs -n 1 echo line # 输出：
#line 1
#line 2
```

对每个 `b` 文件查询 `hello`：

```sh
find . b | xargs grep hello
```

通过测试：

```
sh < xargstest.sh
```

具体而言，是初始目录下的如下指令组成的脚本：

```sh
mkdir a
echo hello > a/b
mkdir c
echo hello > c/b
echo hello > b
find . b | xargs grep hello
```

预期输出：(每一个 `$ ` 对应执行一行然后没输出)

```
$ $ $ $ $ $ hello
hello
hello
$ $
```

参考需要的命令：

- `int exec(char*, char**)` 第一个参数是代码文件名，加载该代码文件并用第二个参数代表的参数执行，执行出错时返回

##### 实现

从标准输入读取管道内容，每次读到空白字符时存一下当前单词，将它追加到 argv 去，每次读到换行时，对当前维护的 argv，开一个 fork 去执行 xargs 指令。注意尾处理。整体而言还是一个字符串小模拟。

参考实现：

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"
#include "kernel/fs.h"

void run(char *program, char **args)
{
    if (fork() == 0)
    {
        exec(program, args);
        exit(0);
    }
}
int main(int argc, char *argv[])
{
    // the below purpose is to delete the argv[0]
    //  128 pointers pointing argv
    char *pargs[128];
    // the first position have no argv
    char **args = pargs;
    for (int i = 1; i < argc; ++i)
    {
        *args = argv[i];
        ++args;
    }

    // stored the chars read from stdin
    char buf[2048];
    // p is latest position, last_p is last word's first char's position
    char *p = buf, *last_p = buf;
    // the prefix (cmd to exec xargs)
    char **pa = args;
    // read from stdin
    for (; read(0, p, 1) != 0; ++p)
    {
        if (*p == ' ' || *p == '\n') // get a word
        {
            *p = '\0';
            *pa = last_p; // add a word to pargs
            pa++;
            last_p = p + 1; // next word in future
            if (*p == '\n')
            {
                *pa = 0; // nullptr
                run(argv[1], pargs);
                pa = args; // revoke what read in the line
            }
        }
    }
    // the last line have no \n
    if (pa != args)
    {
        *p = '\0';
        *(pa++) = last_p;
        *pa = 0;
        run(argv[1], pargs);
    }
    while (wait(0) != -1)
        ;
    exit(0);
}
```

#### uptime

##### 要求

选做任务。

调用系统函数 `uptime()`，返回一个整数，输出从系统运行到现在的时间刻数量(tick)。一秒大约20左右tick，没细测。

##### 实现

直接调库。

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

int main() {
	printf("%d\n", uptime());
	exit(0);
}
```

#### find.grep

##### 要求

选做任务。

修改 `find.c`，参照 `grep.c` 的 `match` 函数，将 `find` 改成支持基础通配符如 `.*^$`。

##### 实现

直接照抄 `grep.c` 的 `match` 函数和它依赖的两个函数，因为不确定能不能直接 `include grep`，所以直接把这几个函数 CV 了，放到 `find` 里，然后对 `case T_FILE` 的 if，直接改成 `match(target,path)`。

注意到 `match(char *re, char *text)` 是查看 re 是否是 text 的前缀的意思，为了准确查找，而不只是前缀，不妨修改 `target` 为 `/target/`，目标串后面也加一个 `/`。考虑到 `*` 是贪心，所以有 `*` 就不加，否则加。

> 经过测试，怀疑他标准实现的 match 有误，所以忽略该任务，这不是操作系统的重点，所以暂且不管了。放弃对通配符的支持。
>
> 具体而言，match 参数分别为 `/p*g /grind/`，能匹配出来，但 `/p*g /pingpong/` 匹配不出来，这是不符合 match 规则的。
>
> 感觉跟操作系统关系不大，这里不做了。

#### sh

##### 要求

选做任务。

对 `user/sh.c`，改进：

- 处理文件时不输出 `$`
- 支持 `wait`
- 支持 `;` 分隔一行多个指令
- 支持子命令 `()`。在括号内的命令将在一个新的 shell 进程中执行
- 支持 tab 补全
- 支持 shell 命令历史

##### 实现

> 感觉跟操作系统关系不大，这里不做了。

> 没做，一个实现的版本 [参考](https://github.com/Miigon/my-xv6-labs-2020/commit/5f91ae357e5dbc031e4164e13141e6096596656d#diff-c5682e6f79d8e68b805047fc80c703adb4dbb0b972fa009bdfed1ea69dddd93f)





### lab2 system calls

[任务要求](https://pdos.csail.mit.edu/6.S081/2021/labs/syscall.html)

做增量更新，进行：

```sh
git remote add origin2 git://g.csail.mit.edu/xv6-labs-2021
git fetch remote2 # 如果没挂或挂了多个remote灵活处理
git merge origin2/syscall # 合并冲突的话自行处理
make clean # 清空文件系统
```

预计能正常跑。

我遇到的冲突是 `Makefile` 和 `conf/lab.mk` 和 `user/usys.pl`，我 `Makefile` 用自己的，后两个用他新的。

#### trace

##### 要求

设计一个 `trace` 系统调用来追踪系统调用。传入一个整数参数 mask，位表示要追踪的系统调用，如追踪 `fork` 则调用 `trace(1 << SYS_fork)`，其中该常量可以在 `kernel/syscall.h` 查看。

输出一行表示对应系统调用的进程 id，系统调用的名字和返回值。追踪的进程包含该进程所 fork 的。

提供了 `user/trace.c` 提供用户态对 `trace` 的调用。

参考正常的测试用例和结果：

```sh
$ trace 32 grep hello README
3: syscall read -> 1023 #箭头右边的可能有所不一样
3: syscall read -> 966
3: syscall read -> 70
3: syscall read -> 0
$
$ trace 2147483647 grep hello README
4: syscall trace -> 0
4: syscall exec -> 3
4: syscall open -> 3
4: syscall read -> 1023
4: syscall read -> 966
4: syscall read -> 70
4: syscall read -> 0
4: syscall close -> 0
$
$ grep hello README
$
$ trace 2 usertests forkforkfork
usertests starting
test forkforkfork: 407: syscall fork -> 408
408: syscall fork -> 409
409: syscall fork -> 410
410: syscall fork -> 411
409: syscall fork -> 412
410: syscall fork -> 413
409: syscall fork -> 414
411: syscall fork -> 415
... #最后输出ALL TESTS PASSED
$   
```

测试用例解释：

- `32` 是 `SYS_read`
- `2147483647` 包含全部系统调用
- 第三个命令没有追踪
- 第四个命令，`usertests` 对应的源文件几千行代码。

应该做的事情：

- 把 `user/trace.c` 加到 makefile。
- 运行 `make qemu` 无法编译 `user/trace.c`，因为系统调用还没存在。需要在 `user/user.h` 添加对 `trace` 系统调用的定义，这是与 makefile 调用的 perl 脚本 `user/usys.pl` 相关的，该脚本生成 `user/usys.S`。系统调用使用 RISC-V `ecall` 指令去转入内核。如果这些做好了，调用 `trace 32 grep hello README` 还是会 fail，因为还没实现内核系统调用
- 因此，需要增加 `sys_trace()` 函数在 `kernel/sysproc.c`，把 `trace` 函数卸载 `kernel/proc.h` 里，然后在 `kernel/syscall.c` 添加内容暴露给用户空间。可以查看已有代码模仿着写。
- 修改 `fork()` 函数(在 `kernel/proc.c`)，让子进程复制 `trace mask`。
- 修改 `kernel/syscall.c` 的 `syscall()` 函数，来打印 trace 输出。增加一个数组表示系统调用的名字和下标。

##### 实现

在 `kernel/sysproc.c` 添加代码如下：

```c
uint64
sys_trace(void)
{
  int mask;
  if(argint(0,&mask)<0) {
    return -1;
  }
  myproc()->syscall_trace = mask;
  return 0;
}
```

在 `kernel/syscall.h` 添加一行：

```c
#define SYS_trace  22
```

在 `kernel/syscall.c` 添加新的函数声明：

```c
extern uint64 sys_trace(void);
```

在同文件的 `static uint64 (*syscalls[])(void) = ` 添加：

```c
[SYS_trace]   sys_trace,
```

具体而言，这是一个函数指针数组，`static` 表示私有，只有定义它的源文件可以访问，`uint64` 是函数返回值，`(*syscalls[])` 是不定数目的函数指针数组，`(void)` 是函数传入的参数。`[SYS_trace]` 是下标索引，`sys_trace` 是函数名字，具体指代 `kernel/sysproc.c` 定义的那个函数。除了这些下标(`SYS_trace` 在刚刚 `kernel/syscall.h` 定义了)外，其他元素填充 0，达成数组。如：`int arr[] = {[3] 2333, [6] 6666}`。

在 `user/usys.pl`，加入用户态到内核态跳板函数：

```perl
entry("trace");
```

该脚本运行后，生成汇编文件 `usys.S`，定义了跳板函数如：

```assembly
.global trace
trace:		# 定义用户态跳板函数
 li a7, SYS_trace	# 将系统调用 id 存入 a7 寄存器
 ecall				# ecall，调用 system call ，跳到内核态的统一系统调用处理函数 syscall()  (syscall.c)
 ret
```

在 `user/user.h` 添加定义：

```c
int trace(int);
```

梳理一下，各代码文件功能：

```
user/user.h:		用户态程序调用跳板函数 trace()
user/usys.S:		跳板函数 trace() 使用 CPU 提供的 ecall 指令，调用到内核态
kernel/syscall.c	到达内核态统一系统调用处理函数 syscall()，所有系统调用都会跳到这里来处理。
kernel/syscall.c	syscall() 根据跳板传进来的系统调用编号，查询 syscalls[] 表，找到对应的内核函数并调用。
kernel/sysproc.c	到达 sys_trace() 函数，执行具体内核操作
```

主要目的是实现用户态和内核态的良好隔离。

由于内核与用户进程的页表不同，寄存器也不互通，所以参数无法直接通过 C 语言参数的形式传过来，而是需要使用 argaddr、argint、argstr 等系列函数，从进程的 trapframe 中读取用户进程寄存器中的参数。

同时由于页表不同，指针也不能直接互通访问（也就是内核不能直接对用户态传进来的指针进行解引用），而是需要使用 copyin、copyout 方法结合进程的页表，才能顺利找到用户态指针（逻辑地址）对应的物理内存地址。

修改 `kernel/proc.h` 的 `struct proc`，添加成员 `uint64 syscall_trace;`。在 `kernel/proc.c` 创建新进程时，给该成员赋初始值 0，具体而言，在 `allocproc` 函数 return 前添加：

```c
p->syscall_trace = 0;
```

如此便能看懂最开始添加的那一段 `sys_trace` 代码。

修改 `kernel/proc.c` 的 `fork` 函数，找到复制进程代码，在其之后添加复制 `syscall_trace` 成员的代码，具体而言：

```c
safestrcpy(np->name, p->name, sizeof(p->name));
np->syscall_trace = p->syscall_trace;//新加的
pid = np->pid;
```

根据上方提到的系统调用的全流程，可以知道，所有的系统调用到达内核态后，都会进入到 syscall() 这个函数进行处理，所以要跟踪所有的内核函数，只需要在 syscall() 函数里埋点就行了。

在 `kernel/syscall.c` 找到 `syscall` 函数，if 分支尾部追加：

```c
if((p->syscall_trace >> num) & 1) {
    printf("%d: syscall %s -> %d\n",p->pid, syscall_names[num], p->trapframe->a0); // syscall_names[num]: 从 syscall 编号到 syscall 名的映射表
}
```

其中，`syscall_names` 未定义，故同文件内定义：

```c
const char *syscall_names[] = {
    [SYS_fork]    "fork",
    [SYS_exit]    "exit",
    [SYS_wait]    "wait",
    [SYS_pipe]    "pipe",
    [SYS_read]    "read",
    [SYS_kill]    "kill",
    [SYS_exec]    "exec",
    [SYS_fstat]   "fstat",
    [SYS_chdir]   "chdir",
    [SYS_dup]     "dup",
    [SYS_getpid]  "getpid",
    [SYS_sbrk]    "sbrk",
    [SYS_sleep]   "sleep",
    [SYS_uptime]  "uptime",
    [SYS_open]    "open",
    [SYS_write]   "write",
    [SYS_mknod]   "mknod",
    [SYS_unlink]  "unlink",
    [SYS_link]    "link",
    [SYS_mkdir]   "mkdir",
    [SYS_close]   "close",
    [SYS_trace]   "trace",
};
```

最后别忘了 `makefile` 在 `UPROGS=` 添加：

```makefile
$U/_trace\
```

至此，可以 `make qemu` 了。执行上面的测试，预期可以通过。



#### sysinfo

##### 要求

添加系统调用 `sysinfo`，收集正在运行的系统的信息。占用一个参数，对 `struct sysinfo` 的指针(查看 `kernel/sysinfo.h`)，结构体含空余字节内存数(`freemem`)和运行进程数(`nproc`)两个 unit64 成员。有测试程序 `user/sysinfotest.c`，帮助测试实现是否正确。具体 `make qemu` 然后执行 `sysinfotest` 即可。

需要

- 把 `sysinfotest` 添加到 makefile
- 添加 `sysinfo` 系统调用，预定义已存在的 `struct sysinfo`。将其复制到用户态，参考 `kernel/sysfile.c` 的 `sys_fstat()` 和 `kernel/file.c` 的 `filestat()` 参考如何使用 `copyout()`。
- 在 `kernel/kalloc.c` 添加统计内存的函数，在 `kernel/proc.c` 添加统计进程的函数。

##### 实现

常见的记录空闲页的方法有：空闲表法、空闲链表法、位示图法（位图法）、成组链接法。这里 xv6 采用的是空闲链表法。

可以看到 `kalloc.c` 里有一个结构体变量名为 `kmem`，包含单向链表 `freelist` 和 `lock` 自旋锁。所以正确的做法是先获取自旋锁，然后遍历 `kmem` 的单向链表，它有几个节点，每个节点代表一页，就乘以每页的大小单位(在 `kernel/riscv.h` 的常量 `PGSIZE`)，计算完后释放锁。注意不要维护一个什么变量动态在每次页发生变化时改变空闲内存数，要查时暴力查询即可。

模仿 `kalloc.c` 的 `kalloc` 函数，知道如何操作锁、遍历链表。可以看到每次分配新空间的办法是把单向链表第一个节点丢出去，根节点后移一位。同理，回收办法是把新空闲挂到单向链表头部。

因为是读，不用写，所以不加锁也行。

参考：

```c
uint64
count_free_mem(void)
{
  //acquire(&kmem.lock);
  uint64 cnt = 0; //bytes of free memory
  for(struct run *p = kmem.freelist; p; p = p->next) {
    ++cnt;
  }
  cnt *= PGSIZE;
  //release(&kmem.lock);
  return cnt;
}
```

`kernel/defs.h` 定义了每个 `kernel` 的 `.c` 的函数。所以要统计内存，先定义一个函数，在 `//kalloc.c` 里追加定义：

```c
uint64 count_free_mem(void);
```



运行进程数，同理，去 `proc.c` 定义一个函数。在 `proc.h` 定义了 `struct proc`，有枚举成员 `state`，若枚举值不为 `UNUSED`，则空闲(虽然不懂为什么逻辑反着来的，但是文档就这么说的)。其中，`proc.c` 的空闲表 `struct proc proc[NPROC]` 维护了所有运行中的进程，所以遍历这个数组即可(也可以用指针遍历)。可以不用锁。

参考：

```c
uint64
count_process(void)
{
  uint64 cnt = 0;
  for(int i=0;i<NPROC;++i) {
    struct proc *p = &proc[i]; //pointer avoid copy
    if(p->state != UNUSED) {
      ++cnt;
    }
  }
  return cnt;
}
//更优遍历：for(struct proc *p = proc; p < &proc[NPROC]; p++) {
```

同理追加定义：

```c
uint64 count_process(void);
```



模仿 `kernel/file.c` 的 `filestat()` 对 `copyout` 的格式，可以知道需要 `myproc()` 的页表，地址，结构体和结构体大小。模仿 `sysfile.c` 的 `sys_fstat()` 可知通过 `argaddr` 获取地址。

实现一个 `sys_sysinfo`，在 `kernel/sysproc.c` 添加：

```c
uint64
sys_sysinfo(void)
{
  uint64 addr; //memory to store sysinfo
  if(argaddr(0,&addr)<0){
    return -1;
  }
  struct sysinfo info; //should include "sysinfo.h"
  info.freemem = count_free_mem();
  info.nproc = count_process();
  if(copyout(myproc()->pagetable, addr, (char *)&info, sizeof info) < 0) {
    return -1;
  }
  return 0;
}
```

相应工作：

- `kernel/syscall.h` 添加：

  ```c
  #define SYS_sysinfo 23
  ```

- `kernel/syscall.c` 同 `trace` 理，类似位置添加三处：

  ```c
  extern uint64 sys_sysinfo(void);
  [SYS_sysinfo] sys_sysinfo,
  [SYS_sysinfo] "sysinfo",
  ```

- `Makefile` 的 `UPROGS=` 添加

  ```c
  $U/_sysinfotest\
  ```

- `user/user.h` 两个不同位置添加：(仿照原有 `user.h` 结构可知)

  ```c
  struct sysinfo;
  int sysinfo(struct sysinfo *);
  ```

- `user/usys.pl` 添加：

  ```perl
  entry("sysinfo");
  ```



> 可选任务：
>
> - 输出 `trace` 跟踪的系统调用的参数
> - 计算 `load average` 并输出



### lab3 page tables

[要求](https://pdos.csail.mit.edu/6.S081/2021/labs/pgtbl.html)

页表。

> 废弃的合并步骤：
>
> ```sh
> git merge origin2/pgtbl #不是1是l
> sudo chmod -R 777 /home/lr583/xv6-labs-2021 #按照自己的路径,方便vscode有权限操作
> # usys.pl, usys.h, syscall.c, Makefile 保留双方
> # syscall.h, lab.mk 用新的
> git add 上面那几个文件
> git commit -m "..." #git push
> ```

直接切换分支，将笔记 ctrl cv 一下，或者迁移笔记所在分支。这里选择后者。

> 具体关键操作大致为：
>
> ```sh
> git push -u origin master:notes #只存笔记的本地目录下
> ```
>
> github 上修改主要分支为 notes。此时原 master 分支为本来的 lab1+lab2, pgtbl 分支为 lab3+notes(update to lab2)。
>
> 因为 lab2 合并到 lab3 不便，所以放弃了一直更新，直接 lab3 重开，丢弃 lab1+lab2+lab3 合在一起的想法

所以最后直接按照提示暴力合并即可，即：

```sh
git fetch origin2
git checkout origin2/pgtbl
make clean #清除lab2遗留，不然编译挂
make qemu #检验可以编译
```

#### speed up system calls

##### 要求

Linux 等操作系统通过在用户态和内核态间共享只读区域来加速系统调用。因为这样可以避免用户态内核态切换，所以能提高速度。

将 mappings 插入到页表(page table)，实现 `getpid()` 系统调用的优化。

进程创建时，映射一个只读页，使用定义在 `kernel/memlayout.h` 的 `USYSCALL` 虚拟地址(VA)常量。同文件内定义了结构体 `struct usyscall`，有 `int pid` 一个成员。用户态的 `ugetpid()` 已经提供了，需要通过 `pgtbltest` 调用，预期输出 `ugetpid_test: OK`。

提示：

- 通过 `kernel/proc.c` 执行映射，使用 `proc_pagetable()` 函数。
- 选择权限位，使得用户态只能读该页。
- 使用 `mappages()` 功能。
- 在 `allocproc()` 分配和初始化页。
- 释放页，通过 `freeproc()`

> 阅读 `proc_pagetable()` 函数，发现调用了 `kernel/vm.c` 的 `mappages()` 函数，创建从 `va` 开始的虚拟地址的页表项(Page Table Entry, PTE)，指向从 `pa` 开始的物理地址。页大小是 `kernel/riscv.h` 定义的 `PGSIZE` 为 4096 bytes。成功返回 0。
>
> 一个页表 `pagetable_t` 是一个 `uint64`，存储 512 个页表项。因为 512x8=4096，易得。该函数先新建一个页表，然后尝试将 `TRAMPOLINE`(意为蹦床)映射，若失败删除新建的页表；然后将 `TRAPFRAME` 映射，若失败，取消上一个映射，清空页表。
>
> 传入的参数是 `struct proc* p`，表示进程，在 `kernel/proc.h` 定义。需要用到的有 `trapframe` 成员属性(已经被第二个映射用了)，`pid` 成员属性等。
>
> 搜索手册 33 页，可以查到权限位的含义：
>
> - `PTE_V` 是否该 PTE 存在
> - `PTE_R` 允许读
> - `PTE_W` 允许写
> - `PTE_X` 允许 CPU 翻译该页内容并执行
> - `PTE_U` 用户态是否可以用这个页

##### 实现

> [错误参考](https://github.com/jlu-xiurui/MIT6.S081-2021-FALL/blob/master/lab3-pgtbl/pgtbl-2021FALL/2021%20FALL%20Pgtbl.md) [参考](https://zhuanlan.zhihu.com/p/461981225) [同义参考](https://www.cnblogs.com/lawliet12/p/16101516.html)

> `memlayout.h` 无需就地添加 `#define LAB_PGTBL`，虽然本地项目看到 `#ifdef` 没亮，但是如果 `#define` 一下编译就说重定义了。

> 失败品：
>
> 在 `proc_pagetable()` 函数，在两个映射中间，定义一个 `usyscall` 结构体，存储传入的 `p->pid`，具体而言：
>
> ```c
> struct usyscall* usc = (struct usyscall *)kalloc();
> usc->pid = p->pid;
> ```
>
> 根据提示，仿照上下文，知道需要将 `USYSCALL` 映射。仿照上下文，映射过去的用户态物理地址是 `usc` 的地址，需要的权限是 `PTE_R` 和 `PTE_U`，所以使用：
>
> ```c
> if(mappages(pagetable, USYSCALL, PGSIZE, (uint64)usc, PTE_R | PTE_U) < 0) {
> ```
>
> 模仿下面映射，知道至少要释放掉第一个 if 的内容，即把原本那三行内容照搬。除此之外，还要把刚刚定义的 `usc` 释放掉，使用 `kfree` 函数，因此具体有下面代码在 if 内：
>
> ```c
> kfree(usc);
> uvmunmap(pagetable, TRAMPOLINE, 1, 0);
> uvmfree(pagetable, 0);
> return 0;
> ```
>
> 因为申请了 `usc` 和 `USYSCALL`，所以下面那个映射失败了的话也要把这两个万一清理掉，即增设：
>
> ```c
> kfree(usc);
> uvmunmap(pagetable, USYSCALL, 1, 0);
> ```
>
> 在同代码文件的 `proc_freepagetable` 函数，添加：
>
> ```c
> kfree((char *)walkaddr(pagetable,USYSCALL));
> uvmunmap(pagetable, USYSCALL, 1, 0);
> ```
>
> 其中，`walkaddr` 是 `kernel/vm.c` 定义的函数，传入页表和 `va`，返回 `pa`；若返回 `0` 表示没有这样的 `va` 到 `pa` 的映射。



`kernel/proc.h` 对 `proc` 结构体定义追加：

```c
struct usyscall* usyscall;
```

对 `kernel/proc.c` 的 `allocproc` 函数，模仿同函数内 `p->trapframe` 的初始化，其初始化后添加：

```c
if((p->usyscall = (struct usyscall *)kalloc()) == 0){
    freeproc(p);
    release(&p->lock);
    return 0;
}
p->usyscall->pid = p->pid;
```

同文件的 `freeproc()` ，模仿 `trapframe`，添加：

```c
if(p->usyscall)
    kfree((void*)p->usyscall);
p->usyscall = 0;
```

对 `kernel/proc.c` 的 `proc_pagetable` 函数，模仿，`return` 前追加：

```c
if(mappages(pagetable, USYSCALL, PGSIZE,
            (uint64)(p->usyscall), PTE_R | PTE_U) < 0){
    uvmunmap(pagetable, TRAMPOLINE, 1, 0);
    uvmunmap(pagetable, TRAPFRAME, 1, 0);
    uvmfree(pagetable, 0);
    return 0;
}
```

在同文件的 `proc_freepagetable()` 取消映射：

```c
uvmunmap(pagetable, USYSCALL, 1, 0);
```

至此，通过测试。

#### Print a page table

##### 要求

打印一个页表的内容。定义一个函数 `vmprint()`，将 `pagetable_t` 作为参数。执行桉树为 `exec.c` 的方法如下，在 `return argc` 前插入：

```c
if(p->pid==1) vmprint(p->pagetable)
```

将输出第一个进程的页表。需要通过 `pte printout` 测试。具体而言执行：

```sh
./grade-lab-pgtbl pte printout
```

按如下格式输出：

```
page table 0x0000000087f6e000
 ..0: pte 0x0000000021fda801 pa 0x0000000087f6a000
 .. ..0: pte 0x0000000021fda401 pa 0x0000000087f69000
 .. .. ..0: pte 0x0000000021fdac1f pa 0x0000000087f6b000
 .. .. ..1: pte 0x0000000021fda00f pa 0x0000000087f68000
 .. .. ..2: pte 0x0000000021fd9c1f pa 0x0000000087f67000
 ..255: pte 0x0000000021fdb401 pa 0x0000000087f6d000
 .. ..511: pte 0x0000000021fdb001 pa 0x0000000087f6c000
 .. .. ..509: pte 0x0000000021fdd813 pa 0x0000000087f76000
 .. .. ..510: pte 0x0000000021fddc07 pa 0x0000000087f77000
 .. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000
```

第一行是 `vmprint` 的参数。对每个 PTE(页表项)按树级输出，输出信息是：页表项的下标、PTE 的位(虚拟地址大概)、物理地址。不要输出无效的 PTE 项。第一级树从 0 到 255；0 的儿子只有 0，其子为 0,1,2。

提示：

- 将 `vmprint()` 放在 `kernel/vm.c`
- 使用 `kernel/riscv.h` 尾部定义的宏
- 参考 `freewalk` 函数
- 在 `kernel/defs.h` 定义 `vmprint` 的原型，以让 `exec.c` 可以调用
- 使用 `%p` 输出虚拟地址。

##### 实现

> [参考](https://blog.miigon.net/posts/s081-lab3-page-tables/)

在 `kernel/defs.h` 添加：

```c
// vm.c
int vmprint(pagetable_t);
```

按要求在 `kernel/exec.c` 的 `exec` 函数的 `return argc;` 前：

```c
vmprint(p->pagetable);
```

对 `kernel/vm.c` 添加：

```c
int pgtblprint(pagetable_t pagetable, int depth) {
  // there are 2^9 = 512 PTEs in a page table.
  for(int i = 0; i < 512; i++){
    pte_t pte = pagetable[i];
    if(pte & PTE_V) { // valid
      printf("..");
      for(int j=0;j<depth;j++) {
        printf(" ..");
      }
      printf("%d: pte %p pa %p\n", i, pte, PTE2PA(pte));

      // not leaf
      if((pte & (PTE_R|PTE_W|PTE_X)) == 0){
        // this PTE points to a lower-level page table.
        uint64 child = PTE2PA(pte);
        pgtblprint((pagetable_t)child,depth+1);
      }
    }
  }
  return 0;
}

int vmprint(pagetable_t pagetable) {
  printf("page table %p\n", pagetable);
  return pgtblprint(pagetable, 0);
}
```

代码解释：`pte_t` 是 `uint64`。是否有效 `PTE_V`。`PTE2PA` 是定义在 `riscv.h` 的宏函数。如果不是叶子节点，`pte_t` 本身代表一个页表，如果是叶子结点，才代表实际有作用的一个页。所以递归直接把 `pte_t` 作为新的 `pagetable_t` DFS 即可。如果不存在读写执行这样的权限位，代表不是叶子节点。

执行测试，结果通过。

#### Detecting which pages have been accessed

##### 要求

垃圾回收器需要使用哪个页面被访问(读/写)的信息。PTE 会标记位，当解决 TLB(Translation Lookaside Buffer，快表，存储最近使用的虚拟地址到物理地址的映射)缺失时。

实现系统调用 `pgaccess()`，报告哪些页被访问，使用三个参数：

- 第一个用户页的起始虚拟地址
- 要检查的页数
- 存储结果的用户页地址(使用位掩码，一个位一个页，LSB Least significant bit 是第一页。如，1101，最右的 1 是最低有效位，相反是 MSB most significant bit，如最左是 1。大端存储 big endian LSB 存在最低内存地址，MSB 在最高；小端 LSB 最低，MSB 最高，如 0x1234 这个值，大端存储 0x0 地址存 12、0x1 存 34，符合阅读顺序；小端存储 little endian)

提示：

- 实现 `kernel/sysproc.c` 的 `sys_pgaccess()`
- 使用 `argaddr(), argint()` 获取参数
- 输出先存在核态临时缓存，然后用 `copyout()` 复制知道用户态
- 可以设置可以扫描的页数的上限
- `kernel/vm.c` 的 `walk()` 可以找到正确的 PTE
- 定义 `PTE_A` 权限位，在 `kernel/riscv.h`，查手册看具体定义
- 检查后清理 `PTE_A` 位
- `vmprint()` 可以方便 debug

在第 33 页，说明 A 位是 accessed，表明自从上次该位被清除以来，该页面是否被访问过。([参考](https://zhuanlan.zhihu.com/p/461981225))

##### 实现

> 在 xv6 设计里，用户进程在用户态使用各自的用户态页表，但是一旦进入内核态（例如使用了系统调用），则切换到内核页表，已经定义了全局共享的页表，在 `vm.c` 可见已有如下：
>
> ```c
> pagetable_t kernel_pagetable;
> ```

仿照 `riscv.h` 里对 `PTE_?` 的定义，阅读 33 页图表，可知 `PTE_A` 是第六位，即：

```c
#define PTE_A (1L << 6)
```

在`kernel/defs.h` 添加对 `walk` 的定义：

```c
pte_t * walk(pagetable_t, uint64, int);
```



在 `kernel/sysproc.c`，找到 `int sys_pgaccess(void)`，函数体实现：

```c
int pgaccess(pagetable_t pagetable,uint64 start_va, int page_num, uint64 result_va)
{
  if (page_num > 64)
  {
    panic("pgaccess: too much pages");
    return -1;
  }
  unsigned int bitmask = 0;
  int cur_bitmask = 1;
  int count = 0;
  uint64 va = start_va;
  pte_t *pte;
  for (; count < page_num; count++, va += PGSIZE)
  {
    if ((pte = walk(pagetable, va, 0)) == 0)
      panic("pgaccess: pte should exist");
    if ((*pte & PTE_A))
    {
      bitmask |= (cur_bitmask<<count);
      *pte &= ~PTE_A;
    }
  }
  copyout(pagetable,result_va,(char*)&bitmask,sizeof(bitmask));
  return 0;
}

#ifdef LAB_PGTBL
int
sys_pgaccess(void)
{
  // lab pgtbl: your code here.
  uint64 va;
  if(argaddr(0,&va)<0){//0th param is va
    return -1;
  }
  int num;
  if(argint(1,&num)<0){//1st param is num
    return -1;
  }
  uint64 res;
  if(argaddr(2,&res)<0){
    return -1;
  }
  struct proc* p = myproc();
  if(pgaccess(p->pagetable, va, num, res) < 0) {
    return -1;
  }
  return 0;
}
#endif
```

代码解释：

- 参考同文件其他函数获取参数的方式，知道 `argint()` 取 int，`argaddr()` 取 `uint64`。

- 之后使用 `myproc()` 获取当前运行进程，取它的页表，进入核心程序。

- 遍历从 `va` 开始的每一页，页大小是 `PGSIZE`，可以指针加法。进行一个 for。

- `walk()` 函数根据页表项虚拟地址返回页表项指针代表页表内容(一个 uint64 对应一些信息)。根据手册 36 页，可以从 111 页后查表找到，从 PTE 找地址。如果设置了 `alloc` 参数，找不到就分配新的页表。否则找不到就返回 0。

- 每次遍历 `va`，遍历页表找到页表项，如果找到了且有 `PTE_A` 位，即页表项内容的 `1<<6` 位，即 `*pte & PTE_A` 是 1，那么这一位访问过，记录结果，结果的第 i 低位标 1。

  并且，有 `PTE_A` 就清空这个位。这个位的意思是上次询问以来是否访问过。因为询问更新了，现在就是下一个上次询问，所以这个位要清零。

- 阅读 `vm.c` 的定义，参考 `proc.c` 对其的调用，观察可知 `copyout` 的用法，传入当前进程页表，传入调用参数给的存结果的虚拟地址，将数据转成字符串，给定长度，转到对应地方去。

测试，预期全部成功：

```c
make qemu
pgtbltest
```



> 更多选做任务：
>
> - 使用超级页来减少页表的 PTE
> - 从地址 0x0 到 0xFFF 是物理第一页。要求从第二个物理页开始用，对应第一个虚拟页。这是因为 0x0 可以代表空指针，这么做后指向这一页可以意味着空指针越界。
>   - **Unmap the first page of a user process**: 在虚拟内存系统中，内存被分为大小固定的"页"（通常是4KB或其他大小）。"取消映射第一页"意味着使用户进程的第一页不与任何实际的物理内存关联。这样，如果用户进程试图访问这一页的任何地址，它将无法找到对应的物理内存。
>   - **dereferencing a null pointer will result in a fault**: 在大多数编程语言中，空指针（或NULL指针）通常表示为地址`0x0`。如果程序错误地尝试访问（或解引用）一个空指针，由于第一页已被取消映射，该访问将导致一个"错误"或"异常"（通常称为段错误或访问违规）。
>   - **You will have to start the user text segment at, for example, 4096, instead of 0**: 由于第一页（从地址`0x0`到`0xFFF`，总共4KB）已被取消映射，用户进程的代码（也称为"text segment"）必须从第二页开始，即地址`0x1000`（十进制为4096）。这意味着程序的实际执行代码不再从地址`0x0`开始，而是从`0x1000`开始。
> - 添加系统调用来报告脏页，使用 `PTE_D`
