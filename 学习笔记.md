## 环境部署

[环境部署官方参考](https://pdos.csail.mit.edu/6.828/2021/tools.html)

windows 为例，假设已经装了 wsl，在管理员 power shell 启动 wsl。

```sh
wsl -u root # 不然非管理员用户登录
```

安装必要依赖：

```sh
sudo apt-get update && sudo apt-get upgrade
sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu
```

访问 wsl 根目录，在文件资源管理器输入路径：`\\wsl$\Ubuntu-20.04`(具体看自己的 wsl 版本，可以通过 `wsl --list` 查看)

随便找一个目录 clone 并 cd：[参考](http://www.systee.com/posts/4be1f6bb/)

```sh
git clone git://g.csail.mit.edu/xv6-labs-2021
cd xv6-labs-2021
```

编译：

```sh
git checkout util
make qemu
```

之后进入一个 xv6 CLI，可以执行：[参考官方](https://pdos.csail.mit.edu/6.S081/2021/labs/util.html)

```sh
ls
```

退出方法：先按 `ctrl+a`，然后直接按 `x`(不是一边按 `ctrl+a` 一边 `ctrl+x` 或 `ctrl+a+x`)。

vscode 配置，安装插件 `remote-wsl`(或名为 `wsl`，特征为蓝色背景白色企鹅)。[参考](http://www.systee.com/posts/4be1f6bb/)

在 wsl terminal 内在项目根目录执行：`code .`，弹出 vsc 窗口。

更改文件权限，以自己的为例，这样才能让 vsc 和 windows 文件资源管理器可以写：

```sh
sudo chmod -R 777 /home/lr583/xv6-labs-2021
```

因为实际上 wsl 内的东西不在一个逻辑机，所以 git 比较麻烦，必须用 wsl terminal 来 add, commit(本机的 git bash 的话一 `git add .` 就把东西全删了，理由未知)，然后因为用户要用到本机的，所以在 git bash 里搞 `git push`。

对 vsc，注意到在 wsl 和在本机插件独立，所以给 wsl 装一个 `C/C++` 插件。安装完成的话，对要调用的函数，进行 ctrl 单机能定位到出处。

部署完毕，即通过 [要求](https://pdos.csail.mit.edu/6.S081/2021/labs/util.html) 的 boot xv6 任务。

注意到 wsl 内需要配置 git 用户名和邮箱，不然 git log 看到的不是自己，github 也没有自己的 commits 记录。



## 开发任务

### lab1

[参考](https://pdos.csail.mit.edu/6.S081/2021/labs/util.html)

#### sleep

##### 要求

要阅读 [文档](https://pdos.csail.mit.edu/6.S081/2021/xv6/book-riscv-rev2.pdf) 第一章，或参考 `user/echo.c` 写好的方法，查看编写格式，即如何进行输入输出。

注意到 main 函数参数 `argc` 是传进去的参数数目，`argv` 是这些参数。注意到 `argv[1]` 开始才是真的第一个参数，即传入的第二个参数。从 `echo` 也可印证这一点。

根据文档第 13 页，尅一看到 `write` 函数的参数描述，它可以通过 `#include "user/user.h"` 引用，第一个参数是 file descriptor 文件描述符，整数；第二个参数是字符串指针(空指针)，第三个参数是字符数(在 `user/ulib.c` 手写了 `strlen` 函数)，在文档第 13 页头，描述了常用的几个文件描述符：①0 标准输入；②1 标准输出；③2 标准错误输出(`stderr`)

传入一个参数，可以使用 `user/ulib.c` 的 `atoi` 函数转 char 为 int。在 `kernel/sysproc.c` 有 `sys_sleep` 的手写函数，代表了 `sleep` 的核心逻辑。在 `user/user.h` 提供了调用的 `sleep` 函数。`user/usys.S` 汇编语言，部分代码表示进入内核态执行 sleep。

具体而言，检查传入的参数，如果不够 1 个或其他原因报错，正常情况 exit。在根目录看到 `Makefile`，需要添加一些东西。

##### 实现

> 一个参考实现 [here](https://blog.miigon.net/posts/s081-lab1-unix-utilities/) [他的汇总](https://github.com/Miigon/my-xv6-labs-2020)

因为对项目架构不太懂，所以暂且参考了一下现成代码。

具体而言，新建一个 `user/sleep.c`，代码如下：

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"
// the above 3 headers must be includes in such exact orders
int main(int argc, char **argv)
{
    if (argc < 2)
    { //一个 ticks 目测大约 100ms
        printf("usage: sleep <ticks>\n");
    }
    int ticks = atoi(argv[1]);
    sleep(ticks);
    exit(0);
}
```

在 makefile `UPROGS=` 那一堆追加：

```makefile
$U/_sleep\
```

验证正确性：

```sh
make qemu
sleep 10
# 关闭
```

单元测试：

```sh
./grade-lab-util sleep
```

#### pingpong

##### 要求

使用管道，实现一对进程的测试通信。父进程给子进程发送一个字节(byte)，子进程输出 `<pid>: received ping`，然后将收到的字节发回去，父进程输出 `<pid>: received pong`。在 `user/pingpong.c` 实现。

需要用到的函数：

- `int pipe(int*);` 传入一个长为 2 的 int 数组，下标 0 是从管道读取数据的文件描述符，下标 1 是向管道写入数据的文件描述符。参考文档第 15 页。一个管道是半双工的，一方读一方写。

- `int fork(void);` 参考文档第 10 页，创建一个当前进程的子进程，返回新建进程的 pid。新进程的内存内容与原进程一样。此时，进入并发，被新建的进程的 `fork` 返回 0,。所以如果调用了 fork，根据返回值判断当前程序代码是被父进程还是子进程走，需要 if else。

- `int read(int, void*, int);` 第一个参数是管道的第一个下标 0 代表的描述符，代表从这个管道读，第二个参数是 char(按地址传入，或指针)，读一个字节，第三个参数代表第二个参数的字符长度。如果读不到，会阻塞等待，直到读到了再往下走。参考文档第 15 页。如果管道写侧关闭，会返回 0。

  同理有 `int write(int, const void*, int)`，第一个传的是管道下标 1 的值

- `int getpid();` 参考文档第 11 页。直接返回当前进程 pid。

- `int exit(int status)` 参考文档第 11 页。结束运行。参考 11 页尾，0 是成功，1 是失败。

- `int wait(int*)` 参考文档第 11 页。等待直接子进程结束，结束后继续执行，否则阻塞，以传入的状态 `int * status` 结束，返回子进程 pid。更多参见 11 页尾。

##### 实现

按照题意实现即可。

```c
int main(int argc, char **argv)
{
    int pp2c[2]; // pipe parent to child
    pipe(pp2c);
    int pc2p[2]; // pipe child to parent
    pipe(pc2p);
    if (fork() != 0) // parent process
    {
        write(pp2c[1], "+", 1); // any char with length 1
        char c;
        read(pc2p[0], &c, 1); // read char of length 1
        printf("%d: received pong\n", getpid());
        wait(0);
    } else {
        char c;
        read(pp2c[0], &c, 1);
        printf("%d: received ping\n", getpid());
        write(pc2p[1], &c, 1);
    }
    exit(0);
}
```

记得添加 makefile。

测试：

```sh
make qemu
pingpong
```



#### primes

##### 要求

使用管道并发地获取质数，写在 `user/primes.c`，输出 [2,35] 的全部质数。对每个质数，创建一个进程用管道读取它的左邻居，写给它的右邻居。

提示：

- 关闭进程不需要的文件需要小心，否则可能会资源枯竭。
- 首个进程到达 35 时，需要等待管道终止，即它的全部子孙，即主进程应在所有输出都完毕后再关闭
- 注意写侧管道关闭会 read 返回 0
- 最简单是直接把 int 写进管道，而不是格式化

参考实现思路文章 [这里](https://swtch.com/~rsc/thread/)

参考函数：

- `int close(int)` 关闭文件描述符

##### 实现

- 主进程生成 [2,35] 的全部质数
- 子进程1 输出2，筛掉所有 2 的倍数
- 子进程2 输出3，筛掉所有 3 的倍数
- 子进程3 输出5，筛掉所有 5 的倍数
- ……

具体而言，每个进程有一个父，数据交换为 pleft，子从父读全部数据，输出第一个数据，然后剩下的数据把倍数筛了，再丢给下一个进程处理，如此递归，然后每个线程都等待自己的儿子结束自己再结束。

要注意关闭不需要用到的文件描述符，否则跑到 n = 13 的时候就会爆掉，出现读到全是 0 的情况，因为 xv6 每个进程能打开的文件描述符总数只有 16 个，参考 `defs.h` 中的 `NOFILE` 和 `proc.h` 中的 `struct file *ofile[NOFILE]; // Open files`。

由于一个管道会同时打开一个输入文件和一个输出文件，所以一个管道就占用了 2 个文件描述符，并且复制的子进程还会复制父进程的描述符，于是跑到第六七层后，就会由于最末端的子进程出现 16 个文件描述符都被占满的情况，导致新管道创建失败。

所以：

- 关闭管道的两个方向中不需要用到的方向的文件描述符（在具体进程中将管道变成只读/只写）
- 子进程创建后，关闭父进程与祖父进程之间的文件描述符（因为子进程并不需要用到之前 stage 的管道）

参考：

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

void filt(int[2]);
int main(int argc, char **argv)
{
    int input_pipe[2];
    pipe(input_pipe);
    if (fork() != 0) // parent process
    {
        close(input_pipe[0]); // no need to input
        int i;
        for (i = 2; i <= 35; ++i)
        {
            write(input_pipe[1], &i, sizeof i);
        }
        i = -1; // denotes completed
        write(input_pipe[1], &i, sizeof i);
    }
    else
    {
        close(input_pipe[1]); // no need to output
        filt(input_pipe);
        exit(0);
    }
    wait(0);
    exit(0);
}
// pipe left
// read one prime, and delete all its multiples
void filt(int pleft[2])
{
    int p; // prime
    read(pleft[0], &p, sizeof p);
    if (p == -1)
    {
        exit(0);
    }
    printf("prime %d\n", p);

    int pright[2]; // pipe right
    pipe(pright);
    if (fork() != 0) // parent process
    {
        close(pright[0]);
        int val;
        while (read(pleft[0], &val, sizeof val) && val != -1)
        {
            if (val % p)
            {
                write(pright[1], &val, sizeof val);
            }
        }
        val = -1;
        write(pright[1], &val, sizeof val);
        wait(0);
        exit(0);
    }
    else
    {
        close(pright[1]);
        close(pleft[0]);
        filt(pright);
    }
}
```

