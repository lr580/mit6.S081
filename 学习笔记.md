## 环境部署

[环境部署官方参考](https://pdos.csail.mit.edu/6.828/2021/tools.html)

windows 为例，假设已经装了 wsl，在管理员 power shell 启动 wsl。

```sh
wsl -u root # 不然非管理员用户登录
```

安装必要依赖：

```sh
sudo apt-get update && sudo apt-get upgrade
sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu
```

访问 wsl 根目录，在文件资源管理器输入路径：`\\wsl$\Ubuntu-20.04`(具体看自己的 wsl 版本，可以通过 `wsl --list` 查看)

随便找一个目录 clone 并 cd：[参考](http://www.systee.com/posts/4be1f6bb/)

```sh
git clone git://g.csail.mit.edu/xv6-labs-2021
cd xv6-labs-2021
```

编译：

```sh
git checkout util
make qemu
```

之后进入一个 xv6 CLI，可以执行：[参考官方](https://pdos.csail.mit.edu/6.S081/2021/labs/util.html)

```sh
ls
```

退出方法：先按 `ctrl+a`，然后直接按 `x`(不是一边按 `ctrl+a` 一边 `ctrl+x` 或 `ctrl+a+x`)。

vscode 配置，安装插件 `remote-wsl`(或名为 `wsl`，特征为蓝色背景白色企鹅)。[参考](http://www.systee.com/posts/4be1f6bb/)

在 wsl terminal 内在项目根目录执行：`code .`，弹出 vsc 窗口。

更改文件权限，以自己的为例，这样才能让 vsc 和 windows 文件资源管理器可以写：

```sh
sudo chmod -R 777 /home/lr583/xv6-labs-2021
```

因为实际上 wsl 内的东西不在一个逻辑机，所以 git 比较麻烦，必须用 wsl terminal 来 add, commit(本机的 git bash 的话一 `git add .` 就把东西全删了，理由未知)，然后因为用户要用到本机的，所以在 git bash 里搞 `git push`。

对 vsc，注意到在 wsl 和在本机插件独立，所以给 wsl 装一个 `C/C++` 插件。安装完成的话，对要调用的函数，进行 ctrl 单机能定位到出处。

部署完毕，即通过 [要求](https://pdos.csail.mit.edu/6.S081/2021/labs/util.html) 的 boot xv6 任务。

注意到 wsl 内需要配置 git 用户名和邮箱，不然 git log 看到的不是自己，github 也没有自己的 commits 记录。将本机公钥私钥覆盖虚拟机的，如管理员就把 `id_rsa`, `id_rsa.pub` 丢到 `/root/.ssh` 里，可以先通过 vscode WSL 插件丢到项目目录，然后 `mv` 过去即可。



## 开发任务

### lab1 util

[参考](https://pdos.csail.mit.edu/6.S081/2021/labs/util.html) 实现 util

#### sleep

##### 要求

要阅读 [文档](https://pdos.csail.mit.edu/6.S081/2021/xv6/book-riscv-rev2.pdf) 第一章，或参考 `user/echo.c` 写好的方法，查看编写格式，即如何进行输入输出。

注意到 main 函数参数 `argc` 是传进去的参数数目，`argv` 是这些参数。注意到 `argv[1]` 开始才是真的第一个参数，即传入的第二个参数。从 `echo` 也可印证这一点。

根据文档第 13 页，可以看到 `write` 函数的参数描述，它可以通过 `#include "user/user.h"` 引用，第一个参数是 file descriptor 文件描述符，整数；第二个参数是字符串指针(空指针)，第三个参数是字符数(在 `user/ulib.c` 手写了 `strlen` 函数)，在文档第 13 页头，描述了常用的几个文件描述符：①0 标准输入；②1 标准输出；③2 标准错误输出(`stderr`)

传入一个参数，可以使用 `user/ulib.c` 的 `atoi` 函数转 char 为 int。在 `kernel/sysproc.c` 有 `sys_sleep` 的手写函数，代表了 `sleep` 的核心逻辑。在 `user/user.h` 提供了调用的 `sleep` 函数。`user/usys.S` 汇编语言，部分代码表示进入内核态执行 sleep。

具体而言，检查传入的参数，如果不够 1 个或其他原因报错，正常情况 exit。在根目录看到 `Makefile`，需要添加一些东西。

##### 实现

> 一个参考实现 [here](https://blog.miigon.net/posts/s081-lab1-unix-utilities/) [汇总](https://github.com/Miigon/my-xv6-labs-2020)

因为对项目架构不太懂，所以暂且参考了一下现成代码。

具体而言，新建一个 `user/sleep.c`，代码如下：

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"
// the above 3 headers must be includes in such exact orders
int main(int argc, char **argv)
{
    if (argc < 2)
    { //一个 ticks 目测大约 100ms
        printf("usage: sleep <ticks>\n");
    }
    int ticks = atoi(argv[1]);
    sleep(ticks);
    exit(0);
}
```

在 makefile `UPROGS=` 那一堆追加：

```makefile
$U/_sleep\
```

验证正确性：

```sh
make qemu
sleep 10
# 关闭
```

单元测试：

```sh
./grade-lab-util sleep
```

#### pingpong

##### 要求

使用管道，实现一对进程的测试通信。父进程给子进程发送一个字节(byte)，子进程输出 `<pid>: received ping`，然后将收到的字节发回去，父进程输出 `<pid>: received pong`。在 `user/pingpong.c` 实现。

需要用到的函数：

- `int pipe(int*);` 传入一个长为 2 的 int 数组，下标 0 是从管道读取数据的文件描述符，下标 1 是向管道写入数据的文件描述符。参考文档第 15 页。一个管道是半双工的，一方读一方写。

- `int fork(void);` 参考文档第 10 页，创建一个当前进程的子进程，返回新建进程的 pid。新进程的内存内容与原进程一样。此时，进入并发，被新建的进程的 `fork` 返回 0,。所以如果调用了 fork，根据返回值判断当前程序代码是被父进程还是子进程走，需要 if else。

- `int read(int, void*, int);` 第一个参数是管道的第一个下标 0 代表的描述符，代表从这个管道读，第二个参数是 char(按地址传入，或指针)，读一个字节，第三个参数代表第二个参数的字符长度。如果读不到，会阻塞等待，直到读到了再往下走。参考文档第 15 页。如果管道写侧关闭，会返回 0。

  同理有 `int write(int, const void*, int)`，第一个传的是管道下标 1 的值

- `int getpid();` 参考文档第 11 页。直接返回当前进程 pid。

- `int exit(int status)` 参考文档第 11 页。结束运行。参考 11 页尾，0 是成功，1 是失败。

- `int wait(int*)` 参考文档第 11 页。等待直接子进程结束，结束后继续执行，否则阻塞，以传入的状态 `int * status` 结束，返回子进程 pid。更多参见 11 页尾。如果有很多个子，可以 `while(wait(0) != -1);` 自旋等。

##### 实现

按照题意实现即可。

```c
int main(int argc, char **argv)
{
    int pp2c[2]; // pipe parent to child
    pipe(pp2c);
    int pc2p[2]; // pipe child to parent
    pipe(pc2p);
    if (fork() != 0) // parent process
    {
        write(pp2c[1], "+", 1); // any char with length 1
        char c;
        read(pc2p[0], &c, 1); // read char of length 1
        printf("%d: received pong\n", getpid());
        wait(0);
    } else {
        char c;
        read(pp2c[0], &c, 1);
        printf("%d: received ping\n", getpid());
        write(pc2p[1], &c, 1);
    }
    exit(0);
}
```

记得添加 makefile。

测试：

```sh
make qemu
pingpong
```



#### primes

##### 要求

使用管道并发地获取质数，写在 `user/primes.c`，输出 [2,35] 的全部质数。对每个质数，创建一个进程用管道读取它的左邻居，写给它的右邻居。

提示：

- 关闭进程不需要的文件需要小心，否则可能会资源枯竭。
- 首个进程到达 35 时，需要等待管道终止，即它的全部子孙，即主进程应在所有输出都完毕后再关闭
- 注意写侧管道关闭会 read 返回 0
- 最简单是直接把 int 写进管道，而不是格式化

参考实现思路文章 [这里](https://swtch.com/~rsc/thread/)

参考函数：

- `int close(int)` 关闭文件描述符

##### 实现

- 主进程生成 [2,35] 的全部质数
- 子进程1 输出2，筛掉所有 2 的倍数
- 子进程2 输出3，筛掉所有 3 的倍数
- 子进程3 输出5，筛掉所有 5 的倍数
- ……

具体而言，每个进程有一个父，数据交换为 pleft，子从父读全部数据，输出第一个数据，然后剩下的数据把倍数筛了，再丢给下一个进程处理，如此递归，然后每个线程都等待自己的儿子结束自己再结束。

要注意关闭不需要用到的文件描述符，否则跑到 n = 13 的时候就会爆掉，出现读到全是 0 的情况，因为 xv6 每个进程能打开的文件描述符总数只有 16 个，参考 `defs.h` 中的 `NOFILE` 和 `proc.h` 中的 `struct file *ofile[NOFILE]; // Open files`。

由于一个管道会同时打开一个输入文件和一个输出文件，所以一个管道就占用了 2 个文件描述符，并且复制的子进程还会复制父进程的描述符，于是跑到第六七层后，就会由于最末端的子进程出现 16 个文件描述符都被占满的情况，导致新管道创建失败。

所以：

- 关闭管道的两个方向中不需要用到的方向的文件描述符（在具体进程中将管道变成只读/只写）
- 子进程创建后，关闭父进程与祖父进程之间的文件描述符（因为子进程并不需要用到之前 stage 的管道）

参考：

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

void filt(int[2]);
int main(int argc, char **argv)
{
    int input_pipe[2];
    pipe(input_pipe);
    if (fork() != 0) // parent process
    {
        close(input_pipe[0]); // no need to input
        int i;
        for (i = 2; i <= 35; ++i)
        {
            write(input_pipe[1], &i, sizeof i);
        }
        i = -1; // denotes completed
        write(input_pipe[1], &i, sizeof i);
    }
    else
    {
        close(input_pipe[1]); // no need to output
        filt(input_pipe);
        exit(0);
    }
    wait(0);
    exit(0);
}
// pipe left
// read one prime, and delete all its multiples
void filt(int pleft[2])
{
    int p; // prime
    read(pleft[0], &p, sizeof p);
    if (p == -1)
    {
        exit(0);
    }
    printf("prime %d\n", p);

    int pright[2]; // pipe right
    pipe(pright);
    if (fork() != 0) // parent process
    {
        close(pright[0]);
        int val;
        while (read(pleft[0], &val, sizeof val) && val != -1)
        {
            if (val % p)
            {
                write(pright[1], &val, sizeof val);
            }
        }
        val = -1;
        write(pright[1], &val, sizeof val);
        wait(0);
        exit(0);
    }
    else
    {
        close(pright[1]);
        close(pleft[0]);
        filt(pright);
    }
}
```



#### find

##### 要求

编写 `user/find.c`，找到目录下所有特定文件名的文件

参考 `user/ls.c` 查看如何读目录，参考函数：

- `int open(char *file, int flags)` 返回文件描述符，0 是最小的文件描述符，不存在返回负数。参考第 14 页，打开方式在 `kernel/fcntl.h` 描述，分别有 `O_RDONLY`, `O_WRONLY`, `O_RDWR`, `O_CREATE`, `O_TRUNC`。不存在就新建，不论读写。`trunc` 是清空。使用示例参考第 17-18 页。可以用 `|` 来如新建+只写。

- `int fstat(int fd, struct stat *st)` 或 `int stat(char *file, struct stat *st)`

  其中 `stat` 结构体在 `kernel/stat.h` 定义，描述了文件大小、文件是目录还是文件等信息。参考第 18 页。

使用递归来找子目录，不要重复找 `.` 和 `..`。注意对文件系统的改变是持久化的，清空文件系统使用 `make clean`，然后重新 `make qemu`。

`kernel/fs.h` 有 `struct dirent`，对目录用 `int read(int, void*, int)` 时第二个参数是 `fs.h` 里结构体 `dirent` 的地址，第三个参数是其长度，返回成功读取的长度，每次读取该目录的下一个路径，直到读完，可以当迭代器使用。返回成功读取的长度。其中 `dirent` 的成员 `inum` 仿照 `ls.c` 可知为 0 要跳过，`char name[14]` 是该目录下的一个文件名。 

参考测试样例：

```sh
make qemu
echo > b
mkdir a
echo > a/b
echo > a/a #我加的
find . b
# 文件系统包含 ./b 和 ./a/b
```

##### 实现

参考要求，仿照 `ls.c` 格式，不难得出具体实现：

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"
#include "kernel/fs.h"
#include "kernel/fcntl.h"

#define CHAR_LEN 512
void find(char *, char *);
int main(int argc, char *argv[])
{
    if (argc < 3)
    {
        printf("find: too few args");
        exit(0);
    }

    // target = "/"+argv[2] for convenience for cmp
    char target[CHAR_LEN];
    target[0] = '/';
    strcpy(target + 1, argv[2]);

    find(argv[1], target);
    exit(0);
}
// curr path: path, relative name to find: target
void find(char *path, char *target)
{
    int fd;
    fd = open(path, O_RDONLY);
    if (fd < 0)
    {
        fprintf(2, "find: cannot open %s\n", path);
        return;
    }

    struct stat st;
    if (fstat(fd, &st) < 0)
    {
        fprintf(2, "find: cannot stat %s\n", path);
        close(fd);
        return;
    }

    switch (st.type)
    {
    case T_FILE:
        // suffix is target
        if (strcmp(path + strlen(path) - strlen(target), target) == 0)
        {
            printf("%s\n", path);
        }
        break;
    case T_DIR:
    {//make a {} field to contains char buf
        char buf[CHAR_LEN], *p;
        // similar to user/ls.c line 50
        if (strlen(path) + 1 + DIRSIZ + 1 > sizeof buf)
        {
            printf("ls: path too long\n");
            break;
        }

        strcpy(buf, path);     // path prefix
        p = buf + strlen(buf); // pointer move
        *p++ = '/';            // cur pointer

        struct dirent de;
        while (read(fd, &de, sizeof(de)) == sizeof(de))
        {
            // similar to user/ls.c
            if (de.inum == 0)
            {
                continue;
            }
            // copy filename and add into buf, do not change position of p
            memmove(p, de.name, DIRSIZ);
            p[DIRSIZ] = '\0';

            if (stat(buf, &st) < 0)
            {
                printf("find: cannot stat %s\n", buf);
                continue;
            }

            // skip . and ..
            if (strcmp(buf + strlen(buf) - 2, "/.") != 0 &&
                strcmp(buf + strlen(buf) - 3, "/..") != 0)
            {
                find(buf, target);
            }
        }
        break;
    }
    }
    close(fd);
}
```

注意为了方便比较，可以让比较目标设定为 `/` + target，这样刚好对应，cmp 方便，免得假查。这个任务基本上就是对字符串匹配和 DFS 的小模拟，熟悉相关库函数和项目结构即可。

特别注意在 switch 内定义局部变量需要有作用域，所以 case 要加多一层大括号。

#### xagrs

##### 要求

通过管道，将输入传给 `xargs`，将输入逐行传给 xargs 执行其他命令，如：

```sh
echo hello too | xargs echo bye # 等于 xargs echo bye hello too 即 echo 输出拼上去
echo "1\n2" | xargs -n 1 echo line # 输出：
#line 1
#line 2
```

对每个 `b` 文件查询 `hello`：

```sh
find . b | xargs grep hello
```

通过测试：

```
sh < xargstest.sh
```

具体而言，是初始目录下的如下指令组成的脚本：

```sh
mkdir a
echo hello > a/b
mkdir c
echo hello > c/b
echo hello > b
find . b | xargs grep hello
```

预期输出：(每一个 `$ ` 对应执行一行然后没输出)

```
$ $ $ $ $ $ hello
hello
hello
$ $
```

参考需要的命令：

- `int exec(char*, char**)` 第一个参数是代码文件名，加载该代码文件并用第二个参数代表的参数执行，执行出错时返回

##### 实现

从标准输入读取管道内容，每次读到空白字符时存一下当前单词，将它追加到 argv 去，每次读到换行时，对当前维护的 argv，开一个 fork 去执行 xargs 指令。注意尾处理。整体而言还是一个字符串小模拟。

参考实现：

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"
#include "kernel/fs.h"

void run(char *program, char **args)
{
    if (fork() == 0)
    {
        exec(program, args);
        exit(0);
    }
}
int main(int argc, char *argv[])
{
    // the below purpose is to delete the argv[0]
    //  128 pointers pointing argv
    char *pargs[128];
    // the first position have no argv
    char **args = pargs;
    for (int i = 1; i < argc; ++i)
    {
        *args = argv[i];
        ++args;
    }

    // stored the chars read from stdin
    char buf[2048];
    // p is latest position, last_p is last word's first char's position
    char *p = buf, *last_p = buf;
    // the prefix (cmd to exec xargs)
    char **pa = args;
    // read from stdin
    for (; read(0, p, 1) != 0; ++p)
    {
        if (*p == ' ' || *p == '\n') // get a word
        {
            *p = '\0';
            *pa = last_p; // add a word to pargs
            pa++;
            last_p = p + 1; // next word in future
            if (*p == '\n')
            {
                *pa = 0; // nullptr
                run(argv[1], pargs);
                pa = args; // revoke what read in the line
            }
        }
    }
    // the last line have no \n
    if (pa != args)
    {
        *p = '\0';
        *(pa++) = last_p;
        *pa = 0;
        run(argv[1], pargs);
    }
    while (wait(0) != -1)
        ;
    exit(0);
}
```

#### uptime

##### 要求

选做任务。

调用系统函数 `uptime()`，返回一个整数，输出从系统运行到现在的时间刻数量(tick)。一秒大约20左右tick，没细测。

##### 实现

直接调库。

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

int main() {
	printf("%d\n", uptime());
	exit(0);
}
```

#### find.grep

##### 要求

选做任务。

修改 `find.c`，参照 `grep.c` 的 `match` 函数，将 `find` 改成支持基础通配符如 `.*^$`。

##### 实现

直接照抄 `grep.c` 的 `match` 函数和它依赖的两个函数，因为不确定能不能直接 `include grep`，所以直接把这几个函数 CV 了，放到 `find` 里，然后对 `case T_FILE` 的 if，直接改成 `match(target,path)`。

注意到 `match(char *re, char *text)` 是查看 re 是否是 text 的前缀的意思，为了准确查找，而不只是前缀，不妨修改 `target` 为 `/target/`，目标串后面也加一个 `/`。考虑到 `*` 是贪心，所以有 `*` 就不加，否则加。

> 经过测试，怀疑他标准实现的 match 有误，所以忽略该任务，这不是操作系统的重点，所以暂且不管了。放弃对通配符的支持。
>
> 具体而言，match 参数分别为 `/p*g /grind/`，能匹配出来，但 `/p*g /pingpong/` 匹配不出来，这是不符合 match 规则的。
>
> 感觉跟操作系统关系不大，这里不做了。

#### sh

##### 要求

选做任务。

对 `user/sh.c`，改进：

- 处理文件时不输出 `$`
- 支持 `wait`
- 支持 `;` 分隔一行多个指令
- 支持子命令 `()`。在括号内的命令将在一个新的 shell 进程中执行
- 支持 tab 补全
- 支持 shell 命令历史

##### 实现

> 感觉跟操作系统关系不大，这里不做了。

> 没做，一个实现的版本 [参考](https://github.com/Miigon/my-xv6-labs-2020/commit/5f91ae357e5dbc031e4164e13141e6096596656d#diff-c5682e6f79d8e68b805047fc80c703adb4dbb0b972fa009bdfed1ea69dddd93f)





### lab2 system calls

[任务要求](https://pdos.csail.mit.edu/6.S081/2021/labs/syscall.html)

做增量更新，进行：

```sh
git remote add origin2 git://g.csail.mit.edu/xv6-labs-2021
git fetch remote2 # 如果没挂或挂了多个remote灵活处理
git merge remotes/origin2/syscall # 合并冲突的话自行处理
make clean # 清空文件系统
```

预计能正常跑。

我遇到的冲突是 `Makefile` 和 `conf/lab.mk` 和 `user/usys.pl`，我 `Makefile` 用自己的，后两个用他新的。

#### trace

##### 要求

设计一个 `trace` 系统调用来追踪系统调用。传入一个整数参数 mask，位表示要追踪的系统调用，如追踪 `fork` 则调用 `trace(1 << SYS_fork)`，其中该常量可以在 `kernel/syscall.h` 查看。

输出一行表示对应系统调用的进程 id，系统调用的名字和返回值。追踪的进程包含该进程所 fork 的。

提供了 `user/trace.c` 提供用户态对 `trace` 的调用。

参考正常的测试用例和结果：

```sh
$ trace 32 grep hello README
3: syscall read -> 1023 #箭头右边的可能有所不一样
3: syscall read -> 966
3: syscall read -> 70
3: syscall read -> 0
$
$ trace 2147483647 grep hello README
4: syscall trace -> 0
4: syscall exec -> 3
4: syscall open -> 3
4: syscall read -> 1023
4: syscall read -> 966
4: syscall read -> 70
4: syscall read -> 0
4: syscall close -> 0
$
$ grep hello README
$
$ trace 2 usertests forkforkfork
usertests starting
test forkforkfork: 407: syscall fork -> 408
408: syscall fork -> 409
409: syscall fork -> 410
410: syscall fork -> 411
409: syscall fork -> 412
410: syscall fork -> 413
409: syscall fork -> 414
411: syscall fork -> 415
... #最后输出ALL TESTS PASSED
$   
```

测试用例解释：

- `32` 是 `SYS_read`
- `2147483647` 包含全部系统调用
- 第三个命令没有追踪
- 第四个命令，`usertests` 对应的源文件几千行代码。

应该做的事情：

- 把 `user/trace.c` 加到 makefile。
- 运行 `make qemu` 无法编译 `user/trace.c`，因为系统调用还没存在。需要在 `user/user.h` 添加对 `trace` 系统调用的定义，这是与 makefile 调用的 perl 脚本 `user/usys.pl` 相关的，该脚本生成 `user/usys.S`。系统调用使用 RISC-V `ecall` 指令去转入内核。如果这些做好了，调用 `trace 32 grep hello README` 还是会 fail，因为还没实现内核系统调用
- 因此，需要增加 `sys_trace()` 函数在 `kernel/sysproc.c`，把 `trace` 函数卸载 `kernel/proc.h` 里，然后在 `kernel/syscall.c` 添加内容暴露给用户空间。可以查看已有代码模仿着写。
- 修改 `fork()` 函数(在 `kernel/proc.c`)，让子进程复制 `trace mask`。
- 修改 `kernel/syscall.c` 的 `syscall()` 函数，来打印 trace 输出。增加一个数组表示系统调用的名字和下标。

##### 实现

在 `kernel/sysproc.c` 添加代码如下：

```c
uint64
sys_trace(void)
{
  int mask;
  if(argint(0,&mask)<0) {
    return -1;
  }
  myproc()->syscall_trace = mask;
  return 0;
}
```

在 `kernel/syscall.h` 添加一行：

```c
#define SYS_trace  22
```

在 `kernel/syscall.c` 添加新的函数声明：

```c
extern uint64 sys_trace(void);
```

在同文件的 `static uint64 (*syscalls[])(void) = ` 添加：

```c
[SYS_trace]   sys_trace,
```

具体而言，这是一个函数指针数组，`static` 表示私有，只有定义它的源文件可以访问，`uint64` 是函数返回值，`(*syscalls[])` 是不定数目的函数指针数组，`(void)` 是函数传入的参数。`[SYS_trace]` 是下标索引，`sys_trace` 是函数名字，具体指代 `kernel/sysproc.c` 定义的那个函数。除了这些下标(`SYS_trace` 在刚刚 `kernel/syscall.h` 定义了)外，其他元素填充 0，达成数组。如：`int arr[] = {[3] 2333, [6] 6666}`。

在 `user/usys.pl`，加入用户态到内核态跳板函数：

```perl
entry("trace");
```

该脚本运行后，生成汇编文件 `usys.S`，定义了跳板函数如：

```assembly
.global trace
trace:		# 定义用户态跳板函数
 li a7, SYS_trace	# 将系统调用 id 存入 a7 寄存器
 ecall				# ecall，调用 system call ，跳到内核态的统一系统调用处理函数 syscall()  (syscall.c)
 ret
```

在 `user/user.h` 添加定义：

```c
int trace(int);
```

梳理一下，各代码文件功能：

```
user/user.h:		用户态程序调用跳板函数 trace()
user/usys.S:		跳板函数 trace() 使用 CPU 提供的 ecall 指令，调用到内核态
kernel/syscall.c	到达内核态统一系统调用处理函数 syscall()，所有系统调用都会跳到这里来处理。
kernel/syscall.c	syscall() 根据跳板传进来的系统调用编号，查询 syscalls[] 表，找到对应的内核函数并调用。
kernel/sysproc.c	到达 sys_trace() 函数，执行具体内核操作
```

主要目的是实现用户态和内核态的良好隔离。

由于内核与用户进程的页表不同，寄存器也不互通，所以参数无法直接通过 C 语言参数的形式传过来，而是需要使用 argaddr、argint、argstr 等系列函数，从进程的 trapframe 中读取用户进程寄存器中的参数。

同时由于页表不同，指针也不能直接互通访问（也就是内核不能直接对用户态传进来的指针进行解引用），而是需要使用 copyin、copyout 方法结合进程的页表，才能顺利找到用户态指针（逻辑地址）对应的物理内存地址。

修改 `kernel/proc.h` 的 `struct proc`，添加成员 `uint64 syscall_trace;`。在 `kernel/proc.c` 创建新进程时，给该成员赋初始值 0，具体而言，在 `allocproc` 函数 return 前添加：

```c
p->syscall_trace = 0;
```

如此便能看懂最开始添加的那一段 `sys_trace` 代码。

修改 `kernel/proc.c` 的 `fork` 函数，找到复制进程代码，在其之后添加复制 `syscall_trace` 成员的代码，具体而言：

```c
safestrcpy(np->name, p->name, sizeof(p->name));
np->syscall_trace = p->syscall_trace;//新加的
pid = np->pid;
```

根据上方提到的系统调用的全流程，可以知道，所有的系统调用到达内核态后，都会进入到 syscall() 这个函数进行处理，所以要跟踪所有的内核函数，只需要在 syscall() 函数里埋点就行了。

在 `kernel/syscall.c` 找到 `syscall` 函数，if 分支尾部追加：

```c
if((p->syscall_trace >> num) & 1) {
    printf("%d: syscall %s -> %d\n",p->pid, syscall_names[num], p->trapframe->a0); // syscall_names[num]: 从 syscall 编号到 syscall 名的映射表
}
```

其中，`syscall_names` 未定义，故同文件内定义：

```c
const char *syscall_names[] = {
    [SYS_fork]    "fork",
    [SYS_exit]    "exit",
    [SYS_wait]    "wait",
    [SYS_pipe]    "pipe",
    [SYS_read]    "read",
    [SYS_kill]    "kill",
    [SYS_exec]    "exec",
    [SYS_fstat]   "fstat",
    [SYS_chdir]   "chdir",
    [SYS_dup]     "dup",
    [SYS_getpid]  "getpid",
    [SYS_sbrk]    "sbrk",
    [SYS_sleep]   "sleep",
    [SYS_uptime]  "uptime",
    [SYS_open]    "open",
    [SYS_write]   "write",
    [SYS_mknod]   "mknod",
    [SYS_unlink]  "unlink",
    [SYS_link]    "link",
    [SYS_mkdir]   "mkdir",
    [SYS_close]   "close",
    [SYS_trace]   "trace",
};
```

最后别忘了 `makefile` 在 `UPROGS=` 添加：

```makefile
$U/_trace\
```

至此，可以 `make qemu` 了。执行上面的测试，预期可以通过。



#### sysinfo

##### 要求

添加系统调用 `sysinfo`，收集正在运行的系统的信息。占用一个参数，对 `struct sysinfo` 的指针(查看 `kernel/sysinfo.h`)，结构体含空余字节内存数(`freemem`)和运行进程数(`nproc`)两个 unit64 成员。有测试程序 `user/sysinfotest.c`，帮助测试实现是否正确。具体 `make qemu` 然后执行 `sysinfotest` 即可。

需要

- 把 `sysinfotest` 添加到 makefile
- 添加 `sysinfo` 系统调用，预定义已存在的 `struct sysinfo`。将其复制到用户态，参考 `kernel/sysfile.c` 的 `sys_fstat()` 和 `kernel/file.c` 的 `filestat()` 参考如何使用 `copyout()`。
- 在 `kernel/kalloc.c` 添加统计内存的函数，在 `kernel/proc.c` 添加统计进程的函数。

##### 实现

常见的记录空闲页的方法有：空闲表法、空闲链表法、位示图法（位图法）、成组链接法。这里 xv6 采用的是空闲链表法。

可以看到 `kalloc.c` 里有一个结构体变量名为 `kmem`，包含单向链表 `freelist` 和 `lock` 自旋锁。所以正确的做法是先获取自旋锁，然后遍历 `kmem` 的单向链表，它有几个节点，每个节点代表一页，就乘以每页的大小单位(在 `kernel/riscv.h` 的常量 `PGSIZE`)，计算完后释放锁。注意不要维护一个什么变量动态在每次页发生变化时改变空闲内存数，要查时暴力查询即可。

模仿 `kalloc.c` 的 `kalloc` 函数，知道如何操作锁、遍历链表。可以看到每次分配新空间的办法是把单向链表第一个节点丢出去，根节点后移一位。同理，回收办法是把新空闲挂到单向链表头部。

因为是读，不用写，所以不加锁也行。

参考：

```c
uint64
count_free_mem(void)
{
  //acquire(&kmem.lock);
  uint64 cnt = 0; //bytes of free memory
  for(struct run *p = kmem.freelist; p; p = p->next) {
    ++cnt;
  }
  cnt *= PGSIZE;
  //release(&kmem.lock);
  return cnt;
}
```

`kernel/defs.h` 定义了每个 `kernel` 的 `.c` 的函数。所以要统计内存，先定义一个函数，在 `//kalloc.c` 里追加定义：

```c
uint64 count_free_mem(void);
```



运行进程数，同理，去 `proc.c` 定义一个函数。在 `proc.h` 定义了 `struct proc`，有枚举成员 `state`，若枚举值不为 `UNUSED`，则空闲(虽然不懂为什么逻辑反着来的，但是文档就这么说的)。其中，`proc.c` 的空闲表 `struct proc proc[NPROC]` 维护了所有运行中的进程，所以遍历这个数组即可(也可以用指针遍历)。可以不用锁。

参考：

```c
uint64
count_process(void)
{
  uint64 cnt = 0;
  for(int i=0;i<NPROC;++i) {
    struct proc *p = &proc[i]; //pointer avoid copy
    if(p->state != UNUSED) {
      ++cnt;
    }
  }
  return cnt;
}
//更优遍历：for(struct proc *p = proc; p < &proc[NPROC]; p++) {
```

同理追加定义：

```c
uint64 count_process(void);
```



模仿 `kernel/file.c` 的 `filestat()` 对 `copyout` 的格式，可以知道需要 `myproc()` 的页表，地址，结构体和结构体大小。模仿 `sysfile.c` 的 `sys_fstat()` 可知通过 `argaddr` 获取地址。

实现一个 `sys_sysinfo`，在 `kernel/sysproc.c` 添加：

```c
uint64
sys_sysinfo(void)
{
  uint64 addr; //memory to store sysinfo
  if(argaddr(0,&addr)<0){
    return -1;
  }
  struct sysinfo info; //should include "sysinfo.h"
  info.freemem = count_free_mem();
  info.nproc = count_process();
  if(copyout(myproc()->pagetable, addr, (char *)&info, sizeof info) < 0) {
    return -1;
  }
  return 0;
}
```

相应工作：

- `kernel/syscall.h` 添加：

  ```c
  #define SYS_sysinfo 23
  ```

- `kernel/syscall.c` 同 `trace` 理，类似位置添加三处：

  ```c
  extern uint64 sys_sysinfo(void);
  [SYS_sysinfo] sys_sysinfo,
  [SYS_sysinfo] "sysinfo",
  ```

- `Makefile` 的 `UPROGS=` 添加

  ```c
  $U/_sysinfotest\
  ```

- `user/user.h` 两个不同位置添加：(仿照原有 `user.h` 结构可知)

  ```c
  struct sysinfo;
  int sysinfo(struct sysinfo *);
  ```

- `user/usys.pl` 添加：

  ```perl
  entry("sysinfo");
  ```



> 可选任务：
>
> - 输出 `trace` 跟踪的系统调用的参数
> - 计算 `load average` 并输出



### lab3 page tables

页表。
