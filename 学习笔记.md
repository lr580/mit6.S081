## 环境部署

[环境部署官方参考](https://pdos.csail.mit.edu/6.828/2021/tools.html)

windows 为例，假设已经装了 wsl，在管理员 power shell 启动 wsl。

```sh
wsl -u root # 不然非管理员用户登录
```

安装必要依赖：

```sh
sudo apt-get update && sudo apt-get upgrade
sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu
```

访问 wsl 根目录，在文件资源管理器输入路径：`\\wsl$\Ubuntu-20.04`(具体看自己的 wsl 版本，可以通过 `wsl --list` 查看)

随便找一个目录 clone 并 cd：[参考](http://www.systee.com/posts/4be1f6bb/)

```sh
git clone git://g.csail.mit.edu/xv6-labs-2021
cd xv6-labs-2021
```

编译：

```sh
git checkout util
make qemu
```

之后进入一个 xv6 CLI，可以执行：[参考官方](https://pdos.csail.mit.edu/6.S081/2021/labs/util.html)

```sh
ls
```

退出方法：先按 `ctrl+a`，然后直接按 `x`(不是一边按 `ctrl+a` 一边 `ctrl+x` 或 `ctrl+a+x`)。

vscode 配置，安装插件 `remote-wsl`(或名为 `wsl`，特征为蓝色背景白色企鹅)。[参考](http://www.systee.com/posts/4be1f6bb/)

在 wsl terminal 内在项目根目录执行：`code .`，弹出 vsc 窗口。

更改文件权限，以自己的为例，这样才能让 vsc 和 windows 文件资源管理器可以写：

```sh
sudo chmod -R 777 /home/lr583/xv6-labs-2021
```

因为实际上 wsl 内的东西不在一个逻辑机，所以 git 比较麻烦，必须用 wsl terminal 来 add, commit(本机的 git bash 的话一 `git add .` 就把东西全删了，理由未知)，然后因为用户要用到本机的，所以在 git bash 里搞 `git push`。

对 vsc，注意到在 wsl 和在本机插件独立，所以给 wsl 装一个 `C/C++` 插件。安装完成的话，对要调用的函数，进行 ctrl 单机能定位到出处。

部署完毕，即通过 [要求](https://pdos.csail.mit.edu/6.S081/2021/labs/util.html) 的 boot xv6 任务。

注意到 wsl 内需要配置 git 用户名和邮箱，不然 git log 看到的不是自己，github 也没有自己的 commits 记录。将本机公钥私钥覆盖虚拟机的，如管理员就把 `id_rsa`, `id_rsa.pub` 丢到 `/root/.ssh` 里，可以先通过 vscode WSL 插件丢到项目目录，然后 `mv` 过去即可。



## 开发任务

### lab1 util

[参考](https://pdos.csail.mit.edu/6.S081/2021/labs/util.html) 实现 util

#### sleep

##### 要求

要阅读 [文档](https://pdos.csail.mit.edu/6.S081/2021/xv6/book-riscv-rev2.pdf) 第一章，或参考 `user/echo.c` 写好的方法，查看编写格式，即如何进行输入输出。

注意到 main 函数参数 `argc` 是传进去的参数数目，`argv` 是这些参数。注意到 `argv[1]` 开始才是真的第一个参数，即传入的第二个参数。从 `echo` 也可印证这一点。

根据文档第 13 页，可以看到 `write` 函数的参数描述，它可以通过 `#include "user/user.h"` 引用，第一个参数是 file descriptor 文件描述符，整数；第二个参数是字符串指针(空指针)，第三个参数是字符数(在 `user/ulib.c` 手写了 `strlen` 函数)，在文档第 13 页头，描述了常用的几个文件描述符：①0 标准输入；②1 标准输出；③2 标准错误输出(`stderr`)

传入一个参数，可以使用 `user/ulib.c` 的 `atoi` 函数转 char 为 int。在 `kernel/sysproc.c` 有 `sys_sleep` 的手写函数，代表了 `sleep` 的核心逻辑。在 `user/user.h` 提供了调用的 `sleep` 函数。`user/usys.S` 汇编语言，部分代码表示进入内核态执行 sleep。

具体而言，检查传入的参数，如果不够 1 个或其他原因报错，正常情况 exit。在根目录看到 `Makefile`，需要添加一些东西。

##### 实现

> 一个参考实现 [here](https://blog.miigon.net/posts/s081-lab1-unix-utilities/) [汇总](https://github.com/Miigon/my-xv6-labs-2020)

因为对项目架构不太懂，所以暂且参考了一下现成代码。

具体而言，新建一个 `user/sleep.c`，代码如下：

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"
// the above 3 headers must be includes in such exact orders
int main(int argc, char **argv)
{
    if (argc < 2)
    { //一个 ticks 目测大约 100ms
        printf("usage: sleep <ticks>\n");
    }
    int ticks = atoi(argv[1]);
    sleep(ticks);
    exit(0);
}
```

在 makefile `UPROGS=` 那一堆追加：

```makefile
$U/_sleep\
```

验证正确性：

```sh
make qemu
sleep 10
# 关闭
```

单元测试：

```sh
./grade-lab-util sleep
```

#### pingpong

##### 要求

使用管道，实现一对进程的测试通信。父进程给子进程发送一个字节(byte)，子进程输出 `<pid>: received ping`，然后将收到的字节发回去，父进程输出 `<pid>: received pong`。在 `user/pingpong.c` 实现。

需要用到的函数：

- `int pipe(int*);` 传入一个长为 2 的 int 数组，下标 0 是从管道读取数据的文件描述符，下标 1 是向管道写入数据的文件描述符。参考文档第 15 页。一个管道是半双工的，一方读一方写。

- `int fork(void);` 参考文档第 10 页，创建一个当前进程的子进程，返回新建进程的 pid。新进程的内存内容与原进程一样。此时，进入并发，被新建的进程的 `fork` 返回 0,。所以如果调用了 fork，根据返回值判断当前程序代码是被父进程还是子进程走，需要 if else。

- `int read(int, void*, int);` 第一个参数是管道的第一个下标 0 代表的描述符，代表从这个管道读，第二个参数是 char(按地址传入，或指针)，读一个字节，第三个参数代表第二个参数的字符长度。如果读不到，会阻塞等待，直到读到了再往下走。参考文档第 15 页。如果管道写侧关闭，会返回 0。

  同理有 `int write(int, const void*, int)`，第一个传的是管道下标 1 的值

- `int getpid();` 参考文档第 11 页。直接返回当前进程 pid。

- `int exit(int status)` 参考文档第 11 页。结束运行。参考 11 页尾，0 是成功，1 是失败。

- `int wait(int*)` 参考文档第 11 页。等待直接子进程结束，结束后继续执行，否则阻塞，以传入的状态 `int * status` 结束，返回子进程 pid。更多参见 11 页尾。如果有很多个子，可以 `while(wait(0) != -1);` 自旋等。

##### 实现

按照题意实现即可。

```c
int main(int argc, char **argv)
{
    int pp2c[2]; // pipe parent to child
    pipe(pp2c);
    int pc2p[2]; // pipe child to parent
    pipe(pc2p);
    if (fork() != 0) // parent process
    {
        write(pp2c[1], "+", 1); // any char with length 1
        char c;
        read(pc2p[0], &c, 1); // read char of length 1
        printf("%d: received pong\n", getpid());
        wait(0);
    } else {
        char c;
        read(pp2c[0], &c, 1);
        printf("%d: received ping\n", getpid());
        write(pc2p[1], &c, 1);
    }
    exit(0);
}
```

记得添加 makefile。

测试：

```sh
make qemu
pingpong
```



#### primes

##### 要求

使用管道并发地获取质数，写在 `user/primes.c`，输出 [2,35] 的全部质数。对每个质数，创建一个进程用管道读取它的左邻居，写给它的右邻居。

提示：

- 关闭进程不需要的文件需要小心，否则可能会资源枯竭。
- 首个进程到达 35 时，需要等待管道终止，即它的全部子孙，即主进程应在所有输出都完毕后再关闭
- 注意写侧管道关闭会 read 返回 0
- 最简单是直接把 int 写进管道，而不是格式化

参考实现思路文章 [这里](https://swtch.com/~rsc/thread/)

参考函数：

- `int close(int)` 关闭文件描述符

##### 实现

- 主进程生成 [2,35] 的全部质数
- 子进程1 输出2，筛掉所有 2 的倍数
- 子进程2 输出3，筛掉所有 3 的倍数
- 子进程3 输出5，筛掉所有 5 的倍数
- ……

具体而言，每个进程有一个父，数据交换为 pleft，子从父读全部数据，输出第一个数据，然后剩下的数据把倍数筛了，再丢给下一个进程处理，如此递归，然后每个线程都等待自己的儿子结束自己再结束。

要注意关闭不需要用到的文件描述符，否则跑到 n = 13 的时候就会爆掉，出现读到全是 0 的情况，因为 xv6 每个进程能打开的文件描述符总数只有 16 个，参考 `defs.h` 中的 `NOFILE` 和 `proc.h` 中的 `struct file *ofile[NOFILE]; // Open files`。

由于一个管道会同时打开一个输入文件和一个输出文件，所以一个管道就占用了 2 个文件描述符，并且复制的子进程还会复制父进程的描述符，于是跑到第六七层后，就会由于最末端的子进程出现 16 个文件描述符都被占满的情况，导致新管道创建失败。

所以：

- 关闭管道的两个方向中不需要用到的方向的文件描述符（在具体进程中将管道变成只读/只写）
- 子进程创建后，关闭父进程与祖父进程之间的文件描述符（因为子进程并不需要用到之前 stage 的管道）

参考：

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

void filt(int[2]);
int main(int argc, char **argv)
{
    int input_pipe[2];
    pipe(input_pipe);
    if (fork() != 0) // parent process
    {
        close(input_pipe[0]); // no need to input
        int i;
        for (i = 2; i <= 35; ++i)
        {
            write(input_pipe[1], &i, sizeof i);
        }
        i = -1; // denotes completed
        write(input_pipe[1], &i, sizeof i);
    }
    else
    {
        close(input_pipe[1]); // no need to output
        filt(input_pipe);
        exit(0);
    }
    wait(0);
    exit(0);
}
// pipe left
// read one prime, and delete all its multiples
void filt(int pleft[2])
{
    int p; // prime
    read(pleft[0], &p, sizeof p);
    if (p == -1)
    {
        exit(0);
    }
    printf("prime %d\n", p);

    int pright[2]; // pipe right
    pipe(pright);
    if (fork() != 0) // parent process
    {
        close(pright[0]);
        int val;
        while (read(pleft[0], &val, sizeof val) && val != -1)
        {
            if (val % p)
            {
                write(pright[1], &val, sizeof val);
            }
        }
        val = -1;
        write(pright[1], &val, sizeof val);
        wait(0);
        exit(0);
    }
    else
    {
        close(pright[1]);
        close(pleft[0]);
        filt(pright);
    }
}
```



#### find

##### 要求

编写 `user/find.c`，找到目录下所有特定文件名的文件

参考 `user/ls.c` 查看如何读目录，参考函数：

- `int open(char *file, int flags)` 返回文件描述符，0 是最小的文件描述符，不存在返回负数。参考第 14 页，打开方式在 `kernel/fcntl.h` 描述，分别有 `O_RDONLY`, `O_WRONLY`, `O_RDWR`, `O_CREATE`, `O_TRUNC`。不存在就新建，不论读写。`trunc` 是清空。使用示例参考第 17-18 页。可以用 `|` 来如新建+只写。

- `int fstat(int fd, struct stat *st)` 或 `int stat(char *file, struct stat *st)`

  其中 `stat` 结构体在 `kernel/stat.h` 定义，描述了文件大小、文件是目录还是文件等信息。参考第 18 页。

使用递归来找子目录，不要重复找 `.` 和 `..`。注意对文件系统的改变是持久化的，清空文件系统使用 `make clean`，然后重新 `make qemu`。

`kernel/fs.h` 有 `struct dirent`，对目录用 `int read(int, void*, int)` 时第二个参数是 `fs.h` 里结构体 `dirent` 的地址，第三个参数是其长度，返回成功读取的长度，每次读取该目录的下一个路径，直到读完，可以当迭代器使用。返回成功读取的长度。其中 `dirent` 的成员 `inum` 仿照 `ls.c` 可知为 0 要跳过，`char name[14]` 是该目录下的一个文件名。 

参考测试样例：

```sh
make qemu
echo > b
mkdir a
echo > a/b
echo > a/a #我加的
find . b
# 文件系统包含 ./b 和 ./a/b
```

##### 实现

参考要求，仿照 `ls.c` 格式，不难得出具体实现：

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"
#include "kernel/fs.h"
#include "kernel/fcntl.h"

#define CHAR_LEN 512
void find(char *, char *);
int main(int argc, char *argv[])
{
    if (argc < 3)
    {
        printf("find: too few args");
        exit(0);
    }

    // target = "/"+argv[2] for convenience for cmp
    char target[CHAR_LEN];
    target[0] = '/';
    strcpy(target + 1, argv[2]);

    find(argv[1], target);
    exit(0);
}
// curr path: path, relative name to find: target
void find(char *path, char *target)
{
    int fd;
    fd = open(path, O_RDONLY);
    if (fd < 0)
    {
        fprintf(2, "find: cannot open %s\n", path);
        return;
    }

    struct stat st;
    if (fstat(fd, &st) < 0)
    {
        fprintf(2, "find: cannot stat %s\n", path);
        close(fd);
        return;
    }

    switch (st.type)
    {
    case T_FILE:
        // suffix is target
        if (strcmp(path + strlen(path) - strlen(target), target) == 0)
        {
            printf("%s\n", path);
        }
        break;
    case T_DIR:
    {//make a {} field to contains char buf
        char buf[CHAR_LEN], *p;
        // similar to user/ls.c line 50
        if (strlen(path) + 1 + DIRSIZ + 1 > sizeof buf)
        {
            printf("ls: path too long\n");
            break;
        }

        strcpy(buf, path);     // path prefix
        p = buf + strlen(buf); // pointer move
        *p++ = '/';            // cur pointer

        struct dirent de;
        while (read(fd, &de, sizeof(de)) == sizeof(de))
        {
            // similar to user/ls.c
            if (de.inum == 0)
            {
                continue;
            }
            // copy filename and add into buf, do not change position of p
            memmove(p, de.name, DIRSIZ);
            p[DIRSIZ] = '\0';

            if (stat(buf, &st) < 0)
            {
                printf("find: cannot stat %s\n", buf);
                continue;
            }

            // skip . and ..
            if (strcmp(buf + strlen(buf) - 2, "/.") != 0 &&
                strcmp(buf + strlen(buf) - 3, "/..") != 0)
            {
                find(buf, target);
            }
        }
        break;
    }
    }
    close(fd);
}
```

注意为了方便比较，可以让比较目标设定为 `/` + target，这样刚好对应，cmp 方便，免得假查。这个任务基本上就是对字符串匹配和 DFS 的小模拟，熟悉相关库函数和项目结构即可。

特别注意在 switch 内定义局部变量需要有作用域，所以 case 要加多一层大括号。

#### xagrs

##### 要求

通过管道，将输入传给 `xargs`，将输入逐行传给 xargs 执行其他命令，如：

```sh
echo hello too | xargs echo bye # 等于 xargs echo bye hello too 即 echo 输出拼上去
echo "1\n2" | xargs -n 1 echo line # 输出：
#line 1
#line 2
```

对每个 `b` 文件查询 `hello`：

```sh
find . b | xargs grep hello
```

通过测试：

```
sh < xargstest.sh
```

具体而言，是初始目录下的如下指令组成的脚本：

```sh
mkdir a
echo hello > a/b
mkdir c
echo hello > c/b
echo hello > b
find . b | xargs grep hello
```

预期输出：(每一个 `$ ` 对应执行一行然后没输出)

```
$ $ $ $ $ $ hello
hello
hello
$ $
```

参考需要的命令：

- `int exec(char*, char**)` 第一个参数是代码文件名，加载该代码文件并用第二个参数代表的参数执行，执行出错时返回

##### 实现

从标准输入读取管道内容，每次读到空白字符时存一下当前单词，将它追加到 argv 去，每次读到换行时，对当前维护的 argv，开一个 fork 去执行 xargs 指令。注意尾处理。整体而言还是一个字符串小模拟。

参考实现：

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"
#include "kernel/fs.h"

void run(char *program, char **args)
{
    if (fork() == 0)
    {
        exec(program, args);
        exit(0);
    }
}
int main(int argc, char *argv[])
{
    // the below purpose is to delete the argv[0]
    //  128 pointers pointing argv
    char *pargs[128];
    // the first position have no argv
    char **args = pargs;
    for (int i = 1; i < argc; ++i)
    {
        *args = argv[i];
        ++args;
    }

    // stored the chars read from stdin
    char buf[2048];
    // p is latest position, last_p is last word's first char's position
    char *p = buf, *last_p = buf;
    // the prefix (cmd to exec xargs)
    char **pa = args;
    // read from stdin
    for (; read(0, p, 1) != 0; ++p)
    {
        if (*p == ' ' || *p == '\n') // get a word
        {
            *p = '\0';
            *pa = last_p; // add a word to pargs
            pa++;
            last_p = p + 1; // next word in future
            if (*p == '\n')
            {
                *pa = 0; // nullptr
                run(argv[1], pargs);
                pa = args; // revoke what read in the line
            }
        }
    }
    // the last line have no \n
    if (pa != args)
    {
        *p = '\0';
        *(pa++) = last_p;
        *pa = 0;
        run(argv[1], pargs);
    }
    while (wait(0) != -1)
        ;
    exit(0);
}
```

#### uptime

##### 要求

选做任务。

调用系统函数 `uptime()`，返回一个整数，输出从系统运行到现在的时间刻数量(tick)。一秒大约20左右tick，没细测。

##### 实现

直接调库。

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

int main() {
	printf("%d\n", uptime());
	exit(0);
}
```

#### find.grep

##### 要求

选做任务。

修改 `find.c`，参照 `grep.c` 的 `match` 函数，将 `find` 改成支持基础通配符如 `.*^$`。

##### 实现

直接照抄 `grep.c` 的 `match` 函数和它依赖的两个函数，因为不确定能不能直接 `include grep`，所以直接把这几个函数 CV 了，放到 `find` 里，然后对 `case T_FILE` 的 if，直接改成 `match(target,path)`。

注意到 `match(char *re, char *text)` 是查看 re 是否是 text 的前缀的意思，为了准确查找，而不只是前缀，不妨修改 `target` 为 `/target/`，目标串后面也加一个 `/`。考虑到 `*` 是贪心，所以有 `*` 就不加，否则加。

> 经过测试，怀疑他标准实现的 match 有误，所以忽略该任务，这不是操作系统的重点，所以暂且不管了。放弃对通配符的支持。
>
> 具体而言，match 参数分别为 `/p*g /grind/`，能匹配出来，但 `/p*g /pingpong/` 匹配不出来，这是不符合 match 规则的。
>
> 感觉跟操作系统关系不大，这里不做了。

#### sh

##### 要求

选做任务。

对 `user/sh.c`，改进：

- 处理文件时不输出 `$`
- 支持 `wait`
- 支持 `;` 分隔一行多个指令
- 支持子命令 `()`。在括号内的命令将在一个新的 shell 进程中执行
- 支持 tab 补全
- 支持 shell 命令历史

##### 实现

> 感觉跟操作系统关系不大，这里不做了。

> 没做，一个实现的版本 [参考](https://github.com/Miigon/my-xv6-labs-2020/commit/5f91ae357e5dbc031e4164e13141e6096596656d#diff-c5682e6f79d8e68b805047fc80c703adb4dbb0b972fa009bdfed1ea69dddd93f)





### lab2 system calls

[任务要求](https://pdos.csail.mit.edu/6.S081/2021/labs/syscall.html)

做增量更新，进行：

```sh
git fetch # 如果没挂或挂了多个remote灵活处理
git checkout syscall # 合并冲突的话自行处理
make clean # 清空文件系统
```

预计能正常跑。

我遇到的冲突是 `Makefile` 和 `conf/lab.mk` 和 `user/usys.pl`，我 `Makefile` 用自己的，后两个用他新的。
